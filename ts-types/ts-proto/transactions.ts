// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: transactions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";
import { Input, InputContract } from "./inputs";
import { Output, OutputContract } from "./outputs";
import { TransactionPointer } from "./pointers";
import { Receipt } from "./receipts";

export const protobufPackage = "transactions";

export enum TransactionType {
  SCRIPT = 0,
  CREATE = 1,
  MINT = 2,
  UPGRADE = 3,
  UPLOAD = 4,
  BLOB = 5,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "SCRIPT":
      return TransactionType.SCRIPT;
    case 1:
    case "CREATE":
      return TransactionType.CREATE;
    case 2:
    case "MINT":
      return TransactionType.MINT;
    case 3:
    case "UPGRADE":
      return TransactionType.UPGRADE;
    case 4:
    case "UPLOAD":
      return TransactionType.UPLOAD;
    case 5:
    case "BLOB":
      return TransactionType.BLOB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.SCRIPT:
      return "SCRIPT";
    case TransactionType.CREATE:
      return "CREATE";
    case TransactionType.MINT:
      return "MINT";
    case TransactionType.UPGRADE:
      return "UPGRADE";
    case TransactionType.UPLOAD:
      return "UPLOAD";
    case TransactionType.BLOB:
      return "BLOB";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionStatus {
  SUCCESS = 0,
  FAILURE = 1,
  SUBMITTED = 2,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "SUCCESS":
      return TransactionStatus.SUCCESS;
    case 1:
    case "FAILURE":
      return TransactionStatus.FAILURE;
    case 2:
    case "SUBMITTED":
      return TransactionStatus.SUBMITTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.SUCCESS:
      return "SUCCESS";
    case TransactionStatus.FAILURE:
      return "FAILURE";
    case TransactionStatus.SUBMITTED:
      return "SUBMITTED";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PolicyType {
  TIP = 0,
  WITNESS_LIMIT = 1,
  MATURITY = 2,
  MAX_FEE = 3,
  UNRECOGNIZED = -1,
}

export function policyTypeFromJSON(object: any): PolicyType {
  switch (object) {
    case 0:
    case "TIP":
      return PolicyType.TIP;
    case 1:
    case "WITNESS_LIMIT":
      return PolicyType.WITNESS_LIMIT;
    case 2:
    case "MATURITY":
      return PolicyType.MATURITY;
    case 3:
    case "MAX_FEE":
      return PolicyType.MAX_FEE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolicyType.UNRECOGNIZED;
  }
}

export function policyTypeToJSON(object: PolicyType): string {
  switch (object) {
    case PolicyType.TIP:
      return "TIP";
    case PolicyType.WITNESS_LIMIT:
      return "WITNESS_LIMIT";
    case PolicyType.MATURITY:
      return "MATURITY";
    case PolicyType.MAX_FEE:
      return "MAX_FEE";
    case PolicyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction {
  subject: string;
  blockHeight: number;
  txId: Uint8Array;
  txIndex: number;
  type: TransactionType;
  status: TransactionStatus;
  root: Uint8Array;
  witnessIndex: number;
  blobId: Uint8Array;
  inputAssetIds: Uint8Array[];
  isCreate: boolean;
  isMint: boolean;
  isScript: boolean;
  isUpgrade: boolean;
  isUpload: boolean;
  maturity: number;
  mintAmount: number;
  mintAssetId: Uint8Array;
  mintGasPrice: number;
  policyType: number;
  rawPayload: Uint8Array;
  receiptsRoot: Uint8Array;
  salt: Uint8Array;
  script: Uint8Array;
  scriptLength: number;
  scriptData: Uint8Array;
  scriptDataLength: number;
  scriptGasLimit: number;
  subsectionIndex: number;
  subsectionsNumber: number;
  upgradePurpose: number;
  storageSlotsCount: number;
  proofSetCount: number;
  witnessesCount: number;
  inputsCount: number;
  outputsCount: number;
  /** Relationship fields */
  inputContract: InputContract | undefined;
  inputContracts: Uint8Array[];
  inputs: Input[];
  outputContract: OutputContract | undefined;
  outputs: Output[];
  proofSet: Uint8Array[];
  receipts: Receipt[];
  storageSlots: StorageSlot[];
  witnesses: Uint8Array[];
  /** Metadata */
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
  pointer: TransactionPointer | undefined;
}

export interface StorageSlot {
  subject: string;
  txId: Uint8Array;
  key: Uint8Array;
  value: Uint8Array;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface Witness {
  subject: string;
  txId: Uint8Array;
  witnessData: Uint8Array;
  witnessDataLength: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ProofSet {
  subject: string;
  txId: Uint8Array;
  proofHash: Uint8Array;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface Policy {
  subject: string;
  txId: Uint8Array;
  type: PolicyType;
  data: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

function createBaseTransaction(): Transaction {
  return {
    subject: "",
    blockHeight: 0,
    txId: new Uint8Array(0),
    txIndex: 0,
    type: 0,
    status: 0,
    root: new Uint8Array(0),
    witnessIndex: 0,
    blobId: new Uint8Array(0),
    inputAssetIds: [],
    isCreate: false,
    isMint: false,
    isScript: false,
    isUpgrade: false,
    isUpload: false,
    maturity: 0,
    mintAmount: 0,
    mintAssetId: new Uint8Array(0),
    mintGasPrice: 0,
    policyType: 0,
    rawPayload: new Uint8Array(0),
    receiptsRoot: new Uint8Array(0),
    salt: new Uint8Array(0),
    script: new Uint8Array(0),
    scriptLength: 0,
    scriptData: new Uint8Array(0),
    scriptDataLength: 0,
    scriptGasLimit: 0,
    subsectionIndex: 0,
    subsectionsNumber: 0,
    upgradePurpose: 0,
    storageSlotsCount: 0,
    proofSetCount: 0,
    witnessesCount: 0,
    inputsCount: 0,
    outputsCount: 0,
    inputContract: undefined,
    inputContracts: [],
    inputs: [],
    outputContract: undefined,
    outputs: [],
    proofSet: [],
    receipts: [],
    storageSlots: [],
    witnesses: [],
    createdAt: undefined,
    publishedAt: undefined,
    pointer: undefined,
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(16).int64(message.blockHeight);
    }
    if (message.txId.length !== 0) {
      writer.uint32(26).bytes(message.txId);
    }
    if (message.txIndex !== 0) {
      writer.uint32(32).int32(message.txIndex);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.root.length !== 0) {
      writer.uint32(58).bytes(message.root);
    }
    if (message.witnessIndex !== 0) {
      writer.uint32(64).int32(message.witnessIndex);
    }
    if (message.blobId.length !== 0) {
      writer.uint32(74).bytes(message.blobId);
    }
    for (const v of message.inputAssetIds) {
      writer.uint32(82).bytes(v!);
    }
    if (message.isCreate !== false) {
      writer.uint32(88).bool(message.isCreate);
    }
    if (message.isMint !== false) {
      writer.uint32(96).bool(message.isMint);
    }
    if (message.isScript !== false) {
      writer.uint32(104).bool(message.isScript);
    }
    if (message.isUpgrade !== false) {
      writer.uint32(112).bool(message.isUpgrade);
    }
    if (message.isUpload !== false) {
      writer.uint32(120).bool(message.isUpload);
    }
    if (message.maturity !== 0) {
      writer.uint32(128).int32(message.maturity);
    }
    if (message.mintAmount !== 0) {
      writer.uint32(136).int64(message.mintAmount);
    }
    if (message.mintAssetId.length !== 0) {
      writer.uint32(146).bytes(message.mintAssetId);
    }
    if (message.mintGasPrice !== 0) {
      writer.uint32(152).int64(message.mintGasPrice);
    }
    if (message.policyType !== 0) {
      writer.uint32(160).int32(message.policyType);
    }
    if (message.rawPayload.length !== 0) {
      writer.uint32(170).bytes(message.rawPayload);
    }
    if (message.receiptsRoot.length !== 0) {
      writer.uint32(178).bytes(message.receiptsRoot);
    }
    if (message.salt.length !== 0) {
      writer.uint32(186).bytes(message.salt);
    }
    if (message.script.length !== 0) {
      writer.uint32(194).bytes(message.script);
    }
    if (message.scriptLength !== 0) {
      writer.uint32(200).int64(message.scriptLength);
    }
    if (message.scriptData.length !== 0) {
      writer.uint32(210).bytes(message.scriptData);
    }
    if (message.scriptDataLength !== 0) {
      writer.uint32(216).int64(message.scriptDataLength);
    }
    if (message.scriptGasLimit !== 0) {
      writer.uint32(224).int64(message.scriptGasLimit);
    }
    if (message.subsectionIndex !== 0) {
      writer.uint32(232).int32(message.subsectionIndex);
    }
    if (message.subsectionsNumber !== 0) {
      writer.uint32(240).int32(message.subsectionsNumber);
    }
    if (message.upgradePurpose !== 0) {
      writer.uint32(248).int32(message.upgradePurpose);
    }
    if (message.storageSlotsCount !== 0) {
      writer.uint32(256).int64(message.storageSlotsCount);
    }
    if (message.proofSetCount !== 0) {
      writer.uint32(264).int32(message.proofSetCount);
    }
    if (message.witnessesCount !== 0) {
      writer.uint32(272).int32(message.witnessesCount);
    }
    if (message.inputsCount !== 0) {
      writer.uint32(280).int32(message.inputsCount);
    }
    if (message.outputsCount !== 0) {
      writer.uint32(288).int32(message.outputsCount);
    }
    if (message.inputContract !== undefined) {
      InputContract.encode(message.inputContract, writer.uint32(298).fork()).join();
    }
    for (const v of message.inputContracts) {
      writer.uint32(306).bytes(v!);
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.outputContract !== undefined) {
      OutputContract.encode(message.outputContract, writer.uint32(322).fork()).join();
    }
    for (const v of message.outputs) {
      Output.encode(v!, writer.uint32(330).fork()).join();
    }
    for (const v of message.proofSet) {
      writer.uint32(338).bytes(v!);
    }
    for (const v of message.receipts) {
      Receipt.encode(v!, writer.uint32(346).fork()).join();
    }
    for (const v of message.storageSlots) {
      StorageSlot.encode(v!, writer.uint32(354).fork()).join();
    }
    for (const v of message.witnesses) {
      writer.uint32(362).bytes(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(370).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(378).fork()).join();
    }
    if (message.pointer !== undefined) {
      TransactionPointer.encode(message.pointer, writer.uint32(386).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.txIndex = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.root = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.witnessIndex = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.blobId = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.inputAssetIds.push(reader.bytes());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isCreate = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isMint = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isScript = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isUpgrade = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isUpload = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.maturity = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.mintAmount = longToNumber(reader.int64());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.mintAssetId = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.mintGasPrice = longToNumber(reader.int64());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.policyType = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.rawPayload = reader.bytes();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.receiptsRoot = reader.bytes();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.salt = reader.bytes();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.scriptLength = longToNumber(reader.int64());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.scriptData = reader.bytes();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.scriptDataLength = longToNumber(reader.int64());
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.scriptGasLimit = longToNumber(reader.int64());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.subsectionIndex = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.subsectionsNumber = reader.int32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.upgradePurpose = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.storageSlotsCount = longToNumber(reader.int64());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.proofSetCount = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.witnessesCount = reader.int32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.inputsCount = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.outputsCount = reader.int32();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.inputContract = InputContract.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.inputContracts.push(reader.bytes());
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.outputContract = OutputContract.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.outputs.push(Output.decode(reader, reader.uint32()));
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.proofSet.push(reader.bytes());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.receipts.push(Receipt.decode(reader, reader.uint32()));
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.storageSlots.push(StorageSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.witnesses.push(reader.bytes());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.pointer = TransactionPointer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      blockHeight: isSet(object.blockHeight) ? globalThis.Number(object.blockHeight) : 0,
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      txIndex: isSet(object.txIndex) ? globalThis.Number(object.txIndex) : 0,
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      root: isSet(object.root) ? bytesFromBase64(object.root) : new Uint8Array(0),
      witnessIndex: isSet(object.witnessIndex) ? globalThis.Number(object.witnessIndex) : 0,
      blobId: isSet(object.blobId) ? bytesFromBase64(object.blobId) : new Uint8Array(0),
      inputAssetIds: globalThis.Array.isArray(object?.inputAssetIds)
        ? object.inputAssetIds.map((e: any) => bytesFromBase64(e))
        : [],
      isCreate: isSet(object.isCreate) ? globalThis.Boolean(object.isCreate) : false,
      isMint: isSet(object.isMint) ? globalThis.Boolean(object.isMint) : false,
      isScript: isSet(object.isScript) ? globalThis.Boolean(object.isScript) : false,
      isUpgrade: isSet(object.isUpgrade) ? globalThis.Boolean(object.isUpgrade) : false,
      isUpload: isSet(object.isUpload) ? globalThis.Boolean(object.isUpload) : false,
      maturity: isSet(object.maturity) ? globalThis.Number(object.maturity) : 0,
      mintAmount: isSet(object.mintAmount) ? globalThis.Number(object.mintAmount) : 0,
      mintAssetId: isSet(object.mintAssetId) ? bytesFromBase64(object.mintAssetId) : new Uint8Array(0),
      mintGasPrice: isSet(object.mintGasPrice) ? globalThis.Number(object.mintGasPrice) : 0,
      policyType: isSet(object.policyType) ? globalThis.Number(object.policyType) : 0,
      rawPayload: isSet(object.rawPayload) ? bytesFromBase64(object.rawPayload) : new Uint8Array(0),
      receiptsRoot: isSet(object.receiptsRoot) ? bytesFromBase64(object.receiptsRoot) : new Uint8Array(0),
      salt: isSet(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(0),
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
      scriptLength: isSet(object.scriptLength) ? globalThis.Number(object.scriptLength) : 0,
      scriptData: isSet(object.scriptData) ? bytesFromBase64(object.scriptData) : new Uint8Array(0),
      scriptDataLength: isSet(object.scriptDataLength) ? globalThis.Number(object.scriptDataLength) : 0,
      scriptGasLimit: isSet(object.scriptGasLimit) ? globalThis.Number(object.scriptGasLimit) : 0,
      subsectionIndex: isSet(object.subsectionIndex) ? globalThis.Number(object.subsectionIndex) : 0,
      subsectionsNumber: isSet(object.subsectionsNumber) ? globalThis.Number(object.subsectionsNumber) : 0,
      upgradePurpose: isSet(object.upgradePurpose) ? globalThis.Number(object.upgradePurpose) : 0,
      storageSlotsCount: isSet(object.storageSlotsCount) ? globalThis.Number(object.storageSlotsCount) : 0,
      proofSetCount: isSet(object.proofSetCount) ? globalThis.Number(object.proofSetCount) : 0,
      witnessesCount: isSet(object.witnessesCount) ? globalThis.Number(object.witnessesCount) : 0,
      inputsCount: isSet(object.inputsCount) ? globalThis.Number(object.inputsCount) : 0,
      outputsCount: isSet(object.outputsCount) ? globalThis.Number(object.outputsCount) : 0,
      inputContract: isSet(object.inputContract) ? InputContract.fromJSON(object.inputContract) : undefined,
      inputContracts: globalThis.Array.isArray(object?.inputContracts)
        ? object.inputContracts.map((e: any) => bytesFromBase64(e))
        : [],
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      outputContract: isSet(object.outputContract) ? OutputContract.fromJSON(object.outputContract) : undefined,
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => Output.fromJSON(e)) : [],
      proofSet: globalThis.Array.isArray(object?.proofSet) ? object.proofSet.map((e: any) => bytesFromBase64(e)) : [],
      receipts: globalThis.Array.isArray(object?.receipts) ? object.receipts.map((e: any) => Receipt.fromJSON(e)) : [],
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => StorageSlot.fromJSON(e))
        : [],
      witnesses: globalThis.Array.isArray(object?.witnesses)
        ? object.witnesses.map((e: any) => bytesFromBase64(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
      pointer: isSet(object.pointer) ? TransactionPointer.fromJSON(object.pointer) : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.txIndex !== 0) {
      obj.txIndex = Math.round(message.txIndex);
    }
    if (message.type !== 0) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.root.length !== 0) {
      obj.root = base64FromBytes(message.root);
    }
    if (message.witnessIndex !== 0) {
      obj.witnessIndex = Math.round(message.witnessIndex);
    }
    if (message.blobId.length !== 0) {
      obj.blobId = base64FromBytes(message.blobId);
    }
    if (message.inputAssetIds?.length) {
      obj.inputAssetIds = message.inputAssetIds.map((e) => base64FromBytes(e));
    }
    if (message.isCreate !== false) {
      obj.isCreate = message.isCreate;
    }
    if (message.isMint !== false) {
      obj.isMint = message.isMint;
    }
    if (message.isScript !== false) {
      obj.isScript = message.isScript;
    }
    if (message.isUpgrade !== false) {
      obj.isUpgrade = message.isUpgrade;
    }
    if (message.isUpload !== false) {
      obj.isUpload = message.isUpload;
    }
    if (message.maturity !== 0) {
      obj.maturity = Math.round(message.maturity);
    }
    if (message.mintAmount !== 0) {
      obj.mintAmount = Math.round(message.mintAmount);
    }
    if (message.mintAssetId.length !== 0) {
      obj.mintAssetId = base64FromBytes(message.mintAssetId);
    }
    if (message.mintGasPrice !== 0) {
      obj.mintGasPrice = Math.round(message.mintGasPrice);
    }
    if (message.policyType !== 0) {
      obj.policyType = Math.round(message.policyType);
    }
    if (message.rawPayload.length !== 0) {
      obj.rawPayload = base64FromBytes(message.rawPayload);
    }
    if (message.receiptsRoot.length !== 0) {
      obj.receiptsRoot = base64FromBytes(message.receiptsRoot);
    }
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    if (message.scriptLength !== 0) {
      obj.scriptLength = Math.round(message.scriptLength);
    }
    if (message.scriptData.length !== 0) {
      obj.scriptData = base64FromBytes(message.scriptData);
    }
    if (message.scriptDataLength !== 0) {
      obj.scriptDataLength = Math.round(message.scriptDataLength);
    }
    if (message.scriptGasLimit !== 0) {
      obj.scriptGasLimit = Math.round(message.scriptGasLimit);
    }
    if (message.subsectionIndex !== 0) {
      obj.subsectionIndex = Math.round(message.subsectionIndex);
    }
    if (message.subsectionsNumber !== 0) {
      obj.subsectionsNumber = Math.round(message.subsectionsNumber);
    }
    if (message.upgradePurpose !== 0) {
      obj.upgradePurpose = Math.round(message.upgradePurpose);
    }
    if (message.storageSlotsCount !== 0) {
      obj.storageSlotsCount = Math.round(message.storageSlotsCount);
    }
    if (message.proofSetCount !== 0) {
      obj.proofSetCount = Math.round(message.proofSetCount);
    }
    if (message.witnessesCount !== 0) {
      obj.witnessesCount = Math.round(message.witnessesCount);
    }
    if (message.inputsCount !== 0) {
      obj.inputsCount = Math.round(message.inputsCount);
    }
    if (message.outputsCount !== 0) {
      obj.outputsCount = Math.round(message.outputsCount);
    }
    if (message.inputContract !== undefined) {
      obj.inputContract = InputContract.toJSON(message.inputContract);
    }
    if (message.inputContracts?.length) {
      obj.inputContracts = message.inputContracts.map((e) => base64FromBytes(e));
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.outputContract !== undefined) {
      obj.outputContract = OutputContract.toJSON(message.outputContract);
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => Output.toJSON(e));
    }
    if (message.proofSet?.length) {
      obj.proofSet = message.proofSet.map((e) => base64FromBytes(e));
    }
    if (message.receipts?.length) {
      obj.receipts = message.receipts.map((e) => Receipt.toJSON(e));
    }
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => StorageSlot.toJSON(e));
    }
    if (message.witnesses?.length) {
      obj.witnesses = message.witnesses.map((e) => base64FromBytes(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    if (message.pointer !== undefined) {
      obj.pointer = TransactionPointer.toJSON(message.pointer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.subject = object.subject ?? "";
    message.blockHeight = object.blockHeight ?? 0;
    message.txId = object.txId ?? new Uint8Array(0);
    message.txIndex = object.txIndex ?? 0;
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.root = object.root ?? new Uint8Array(0);
    message.witnessIndex = object.witnessIndex ?? 0;
    message.blobId = object.blobId ?? new Uint8Array(0);
    message.inputAssetIds = object.inputAssetIds?.map((e) => e) || [];
    message.isCreate = object.isCreate ?? false;
    message.isMint = object.isMint ?? false;
    message.isScript = object.isScript ?? false;
    message.isUpgrade = object.isUpgrade ?? false;
    message.isUpload = object.isUpload ?? false;
    message.maturity = object.maturity ?? 0;
    message.mintAmount = object.mintAmount ?? 0;
    message.mintAssetId = object.mintAssetId ?? new Uint8Array(0);
    message.mintGasPrice = object.mintGasPrice ?? 0;
    message.policyType = object.policyType ?? 0;
    message.rawPayload = object.rawPayload ?? new Uint8Array(0);
    message.receiptsRoot = object.receiptsRoot ?? new Uint8Array(0);
    message.salt = object.salt ?? new Uint8Array(0);
    message.script = object.script ?? new Uint8Array(0);
    message.scriptLength = object.scriptLength ?? 0;
    message.scriptData = object.scriptData ?? new Uint8Array(0);
    message.scriptDataLength = object.scriptDataLength ?? 0;
    message.scriptGasLimit = object.scriptGasLimit ?? 0;
    message.subsectionIndex = object.subsectionIndex ?? 0;
    message.subsectionsNumber = object.subsectionsNumber ?? 0;
    message.upgradePurpose = object.upgradePurpose ?? 0;
    message.storageSlotsCount = object.storageSlotsCount ?? 0;
    message.proofSetCount = object.proofSetCount ?? 0;
    message.witnessesCount = object.witnessesCount ?? 0;
    message.inputsCount = object.inputsCount ?? 0;
    message.outputsCount = object.outputsCount ?? 0;
    message.inputContract = (object.inputContract !== undefined && object.inputContract !== null)
      ? InputContract.fromPartial(object.inputContract)
      : undefined;
    message.inputContracts = object.inputContracts?.map((e) => e) || [];
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.outputContract = (object.outputContract !== undefined && object.outputContract !== null)
      ? OutputContract.fromPartial(object.outputContract)
      : undefined;
    message.outputs = object.outputs?.map((e) => Output.fromPartial(e)) || [];
    message.proofSet = object.proofSet?.map((e) => e) || [];
    message.receipts = object.receipts?.map((e) => Receipt.fromPartial(e)) || [];
    message.storageSlots = object.storageSlots?.map((e) => StorageSlot.fromPartial(e)) || [];
    message.witnesses = object.witnesses?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    message.pointer = (object.pointer !== undefined && object.pointer !== null)
      ? TransactionPointer.fromPartial(object.pointer)
      : undefined;
    return message;
  },
};

function createBaseStorageSlot(): StorageSlot {
  return {
    subject: "",
    txId: new Uint8Array(0),
    key: new Uint8Array(0),
    value: new Uint8Array(0),
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const StorageSlot: MessageFns<StorageSlot> = {
  encode(message: StorageSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.key.length !== 0) {
      writer.uint32(26).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(34).bytes(message.value);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlot {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: StorageSlot): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlot>, I>>(base?: I): StorageSlot {
    return StorageSlot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlot>, I>>(object: I): StorageSlot {
    const message = createBaseStorageSlot();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.key = object.key ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseWitness(): Witness {
  return {
    subject: "",
    txId: new Uint8Array(0),
    witnessData: new Uint8Array(0),
    witnessDataLength: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const Witness: MessageFns<Witness> = {
  encode(message: Witness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.witnessData.length !== 0) {
      writer.uint32(26).bytes(message.witnessData);
    }
    if (message.witnessDataLength !== 0) {
      writer.uint32(32).int32(message.witnessDataLength);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Witness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.witnessData = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.witnessDataLength = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Witness {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      witnessData: isSet(object.witnessData) ? bytesFromBase64(object.witnessData) : new Uint8Array(0),
      witnessDataLength: isSet(object.witnessDataLength) ? globalThis.Number(object.witnessDataLength) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: Witness): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.witnessData.length !== 0) {
      obj.witnessData = base64FromBytes(message.witnessData);
    }
    if (message.witnessDataLength !== 0) {
      obj.witnessDataLength = Math.round(message.witnessDataLength);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Witness>, I>>(base?: I): Witness {
    return Witness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Witness>, I>>(object: I): Witness {
    const message = createBaseWitness();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.witnessData = object.witnessData ?? new Uint8Array(0);
    message.witnessDataLength = object.witnessDataLength ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseProofSet(): ProofSet {
  return {
    subject: "",
    txId: new Uint8Array(0),
    proofHash: new Uint8Array(0),
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ProofSet: MessageFns<ProofSet> = {
  encode(message: ProofSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.proofHash.length !== 0) {
      writer.uint32(26).bytes(message.proofHash);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proofHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofSet {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      proofHash: isSet(object.proofHash) ? bytesFromBase64(object.proofHash) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ProofSet): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.proofHash.length !== 0) {
      obj.proofHash = base64FromBytes(message.proofHash);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofSet>, I>>(base?: I): ProofSet {
    return ProofSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofSet>, I>>(object: I): ProofSet {
    const message = createBaseProofSet();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.proofHash = object.proofHash ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBasePolicy(): Policy {
  return { subject: "", txId: new Uint8Array(0), type: 0, data: 0, createdAt: undefined, publishedAt: undefined };
}

export const Policy: MessageFns<Policy> = {
  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.data !== 0) {
      writer.uint32(32).int64(message.data);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.data = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      type: isSet(object.type) ? policyTypeFromJSON(object.type) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.type !== 0) {
      obj.type = policyTypeToJSON(message.type);
    }
    if (message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policy>, I>>(base?: I): Policy {
    return Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policy>, I>>(object: I): Policy {
    const message = createBasePolicy();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.type = object.type ?? 0;
    message.data = object.data ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
