// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: transactions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "./common";
import { Input, InputContract } from "./inputs";
import { Output, OutputContract } from "./outputs";
import { TxPointer } from "./pointers";

export const protobufPackage = "transactions";

export enum TransactionType {
  UNKNOWN_TRANSACTION_TYPE = 0,
  SCRIPT = 1,
  CREATE = 2,
  MINT = 3,
  UPGRADE = 4,
  UPLOAD = 5,
  BLOB = 6,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "UNKNOWN_TRANSACTION_TYPE":
      return TransactionType.UNKNOWN_TRANSACTION_TYPE;
    case 1:
    case "SCRIPT":
      return TransactionType.SCRIPT;
    case 2:
    case "CREATE":
      return TransactionType.CREATE;
    case 3:
    case "MINT":
      return TransactionType.MINT;
    case 4:
    case "UPGRADE":
      return TransactionType.UPGRADE;
    case 5:
    case "UPLOAD":
      return TransactionType.UPLOAD;
    case 6:
    case "BLOB":
      return TransactionType.BLOB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.UNKNOWN_TRANSACTION_TYPE:
      return "UNKNOWN_TRANSACTION_TYPE";
    case TransactionType.SCRIPT:
      return "SCRIPT";
    case TransactionType.CREATE:
      return "CREATE";
    case TransactionType.MINT:
      return "MINT";
    case TransactionType.UPGRADE:
      return "UPGRADE";
    case TransactionType.UPLOAD:
      return "UPLOAD";
    case TransactionType.BLOB:
      return "BLOB";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionStatus {
  UNKNOWN_TRANSACTION_STATUS = 0,
  FAILED = 1,
  SUBMITTED = 2,
  SQUEEZED_OUT = 3,
  SUCCESS = 4,
  NONE = 5,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "UNKNOWN_TRANSACTION_STATUS":
      return TransactionStatus.UNKNOWN_TRANSACTION_STATUS;
    case 1:
    case "FAILED":
      return TransactionStatus.FAILED;
    case 2:
    case "SUBMITTED":
      return TransactionStatus.SUBMITTED;
    case 3:
    case "SQUEEZED_OUT":
      return TransactionStatus.SQUEEZED_OUT;
    case 4:
    case "SUCCESS":
      return TransactionStatus.SUCCESS;
    case 5:
    case "NONE":
      return TransactionStatus.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.UNKNOWN_TRANSACTION_STATUS:
      return "UNKNOWN_TRANSACTION_STATUS";
    case TransactionStatus.FAILED:
      return "FAILED";
    case TransactionStatus.SUBMITTED:
      return "SUBMITTED";
    case TransactionStatus.SQUEEZED_OUT:
      return "SQUEEZED_OUT";
    case TransactionStatus.SUCCESS:
      return "SUCCESS";
    case TransactionStatus.NONE:
      return "NONE";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PolicyType {
  UNKNOWN_POLICY_TYPE = 0,
  TIP = 1,
  WITNESS_LIMIT = 2,
  MATURITY = 3,
  MAX_FEE = 4,
  UNRECOGNIZED = -1,
}

export function policyTypeFromJSON(object: any): PolicyType {
  switch (object) {
    case 0:
    case "UNKNOWN_POLICY_TYPE":
      return PolicyType.UNKNOWN_POLICY_TYPE;
    case 1:
    case "TIP":
      return PolicyType.TIP;
    case 2:
    case "WITNESS_LIMIT":
      return PolicyType.WITNESS_LIMIT;
    case 3:
    case "MATURITY":
      return PolicyType.MATURITY;
    case 4:
    case "MAX_FEE":
      return PolicyType.MAX_FEE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolicyType.UNRECOGNIZED;
  }
}

export function policyTypeToJSON(object: PolicyType): string {
  switch (object) {
    case PolicyType.UNKNOWN_POLICY_TYPE:
      return "UNKNOWN_POLICY_TYPE";
    case PolicyType.TIP:
      return "TIP";
    case PolicyType.WITNESS_LIMIT:
      return "WITNESS_LIMIT";
    case PolicyType.MATURITY:
      return "MATURITY";
    case PolicyType.MAX_FEE:
      return "MAX_FEE";
    case PolicyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction {
  subject: string;
  /** Fields matching fuel-core */
  id: Uint8Array;
  scriptGasLimit: number;
  txPointer: TxPointer | undefined;
  inputAssetIds: Uint8Array[];
  inputContracts: Uint8Array[];
  inputContract: InputContract | undefined;
  inputs: Input[];
  isScript: boolean;
  isCreate: boolean;
  isMint: boolean;
  isUpgrade: boolean;
  isUpload: boolean;
  isBlob: boolean;
  outputs: Output[];
  outputContract: OutputContract | undefined;
  mintAmount: number;
  mintAssetId: Uint8Array;
  mintGasPrice: number;
  receiptsRoot: Uint8Array;
  status: TransactionStatus;
  witnesses: Uint8Array[];
  script: Uint8Array;
  scriptData: Uint8Array;
  policies: Policy | undefined;
  salt: Uint8Array;
  storageSlots: Uint8Array[];
  bytecodeWitnessIndex: number;
  bytecodeRoot: Uint8Array;
  subsectionIndex: number;
  subsectionsNumber: number;
  proofSet: Uint8Array[];
  upgradePurpose: number;
  blobId: Uint8Array;
  /** Extra fields (not in fuel-core) */
  maturity: number;
  policyType: number;
  rawPayload: Uint8Array;
  scriptLength: number;
  scriptDataLength: number;
  storageSlotsCount: number;
  proofSetCount: number;
  witnessesCount: number;
  inputsCount: number;
  outputsCount: number;
  /** Metadata */
  metadata: Metadata | undefined;
}

export interface StorageSlot {
  subject: string;
  txId: Uint8Array;
  key: Uint8Array;
  value: Uint8Array;
}

export interface Witness {
  subject: string;
  txId: Uint8Array;
  witnessData: Uint8Array;
  witnessDataLength: number;
}

export interface ProofSet {
  subject: string;
  txId: Uint8Array;
  proofHash: Uint8Array;
}

export interface Policy {
  subject: string;
  txId: Uint8Array;
  type: PolicyType;
  data: number;
}

function createBaseTransaction(): Transaction {
  return {
    subject: "",
    id: new Uint8Array(0),
    scriptGasLimit: 0,
    txPointer: undefined,
    inputAssetIds: [],
    inputContracts: [],
    inputContract: undefined,
    inputs: [],
    isScript: false,
    isCreate: false,
    isMint: false,
    isUpgrade: false,
    isUpload: false,
    isBlob: false,
    outputs: [],
    outputContract: undefined,
    mintAmount: 0,
    mintAssetId: new Uint8Array(0),
    mintGasPrice: 0,
    receiptsRoot: new Uint8Array(0),
    status: 0,
    witnesses: [],
    script: new Uint8Array(0),
    scriptData: new Uint8Array(0),
    policies: undefined,
    salt: new Uint8Array(0),
    storageSlots: [],
    bytecodeWitnessIndex: 0,
    bytecodeRoot: new Uint8Array(0),
    subsectionIndex: 0,
    subsectionsNumber: 0,
    proofSet: [],
    upgradePurpose: 0,
    blobId: new Uint8Array(0),
    maturity: 0,
    policyType: 0,
    rawPayload: new Uint8Array(0),
    scriptLength: 0,
    scriptDataLength: 0,
    storageSlotsCount: 0,
    proofSetCount: 0,
    witnessesCount: 0,
    inputsCount: 0,
    outputsCount: 0,
    metadata: undefined,
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    if (message.scriptGasLimit !== 0) {
      writer.uint32(24).int64(message.scriptGasLimit);
    }
    if (message.txPointer !== undefined) {
      TxPointer.encode(message.txPointer, writer.uint32(34).fork()).join();
    }
    for (const v of message.inputAssetIds) {
      writer.uint32(42).bytes(v!);
    }
    for (const v of message.inputContracts) {
      writer.uint32(50).bytes(v!);
    }
    if (message.inputContract !== undefined) {
      InputContract.encode(message.inputContract, writer.uint32(58).fork()).join();
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.isScript !== false) {
      writer.uint32(72).bool(message.isScript);
    }
    if (message.isCreate !== false) {
      writer.uint32(80).bool(message.isCreate);
    }
    if (message.isMint !== false) {
      writer.uint32(88).bool(message.isMint);
    }
    if (message.isUpgrade !== false) {
      writer.uint32(96).bool(message.isUpgrade);
    }
    if (message.isUpload !== false) {
      writer.uint32(104).bool(message.isUpload);
    }
    if (message.isBlob !== false) {
      writer.uint32(112).bool(message.isBlob);
    }
    for (const v of message.outputs) {
      Output.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.outputContract !== undefined) {
      OutputContract.encode(message.outputContract, writer.uint32(130).fork()).join();
    }
    if (message.mintAmount !== 0) {
      writer.uint32(136).int64(message.mintAmount);
    }
    if (message.mintAssetId.length !== 0) {
      writer.uint32(146).bytes(message.mintAssetId);
    }
    if (message.mintGasPrice !== 0) {
      writer.uint32(152).int64(message.mintGasPrice);
    }
    if (message.receiptsRoot.length !== 0) {
      writer.uint32(162).bytes(message.receiptsRoot);
    }
    if (message.status !== 0) {
      writer.uint32(168).int32(message.status);
    }
    for (const v of message.witnesses) {
      writer.uint32(178).bytes(v!);
    }
    if (message.script.length !== 0) {
      writer.uint32(186).bytes(message.script);
    }
    if (message.scriptData.length !== 0) {
      writer.uint32(194).bytes(message.scriptData);
    }
    if (message.policies !== undefined) {
      Policy.encode(message.policies, writer.uint32(202).fork()).join();
    }
    if (message.salt.length !== 0) {
      writer.uint32(210).bytes(message.salt);
    }
    for (const v of message.storageSlots) {
      writer.uint32(218).bytes(v!);
    }
    if (message.bytecodeWitnessIndex !== 0) {
      writer.uint32(224).int32(message.bytecodeWitnessIndex);
    }
    if (message.bytecodeRoot.length !== 0) {
      writer.uint32(234).bytes(message.bytecodeRoot);
    }
    if (message.subsectionIndex !== 0) {
      writer.uint32(240).int32(message.subsectionIndex);
    }
    if (message.subsectionsNumber !== 0) {
      writer.uint32(248).int32(message.subsectionsNumber);
    }
    for (const v of message.proofSet) {
      writer.uint32(258).bytes(v!);
    }
    if (message.upgradePurpose !== 0) {
      writer.uint32(264).int32(message.upgradePurpose);
    }
    if (message.blobId.length !== 0) {
      writer.uint32(274).bytes(message.blobId);
    }
    if (message.maturity !== 0) {
      writer.uint32(280).int32(message.maturity);
    }
    if (message.policyType !== 0) {
      writer.uint32(288).int32(message.policyType);
    }
    if (message.rawPayload.length !== 0) {
      writer.uint32(298).bytes(message.rawPayload);
    }
    if (message.scriptLength !== 0) {
      writer.uint32(304).int64(message.scriptLength);
    }
    if (message.scriptDataLength !== 0) {
      writer.uint32(312).int64(message.scriptDataLength);
    }
    if (message.storageSlotsCount !== 0) {
      writer.uint32(320).int64(message.storageSlotsCount);
    }
    if (message.proofSetCount !== 0) {
      writer.uint32(328).int32(message.proofSetCount);
    }
    if (message.witnessesCount !== 0) {
      writer.uint32(336).int32(message.witnessesCount);
    }
    if (message.inputsCount !== 0) {
      writer.uint32(344).int32(message.inputsCount);
    }
    if (message.outputsCount !== 0) {
      writer.uint32(352).int32(message.outputsCount);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(362).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scriptGasLimit = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.txPointer = TxPointer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputAssetIds.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputContracts.push(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inputContract = InputContract.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isScript = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isCreate = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isMint = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isUpgrade = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isUpload = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isBlob = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.outputs.push(Output.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.outputContract = OutputContract.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.mintAmount = longToNumber(reader.int64());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.mintAssetId = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.mintGasPrice = longToNumber(reader.int64());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.receiptsRoot = reader.bytes();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.witnesses.push(reader.bytes());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.scriptData = reader.bytes();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.policies = Policy.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.salt = reader.bytes();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.storageSlots.push(reader.bytes());
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.bytecodeWitnessIndex = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bytecodeRoot = reader.bytes();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.subsectionIndex = reader.int32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.subsectionsNumber = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.proofSet.push(reader.bytes());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.upgradePurpose = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.blobId = reader.bytes();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.maturity = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.policyType = reader.int32();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.rawPayload = reader.bytes();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.scriptLength = longToNumber(reader.int64());
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.scriptDataLength = longToNumber(reader.int64());
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.storageSlotsCount = longToNumber(reader.int64());
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.proofSetCount = reader.int32();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.witnessesCount = reader.int32();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.inputsCount = reader.int32();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.outputsCount = reader.int32();
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      scriptGasLimit: isSet(object.scriptGasLimit) ? globalThis.Number(object.scriptGasLimit) : 0,
      txPointer: isSet(object.txPointer) ? TxPointer.fromJSON(object.txPointer) : undefined,
      inputAssetIds: globalThis.Array.isArray(object?.inputAssetIds)
        ? object.inputAssetIds.map((e: any) => bytesFromBase64(e))
        : [],
      inputContracts: globalThis.Array.isArray(object?.inputContracts)
        ? object.inputContracts.map((e: any) => bytesFromBase64(e))
        : [],
      inputContract: isSet(object.inputContract) ? InputContract.fromJSON(object.inputContract) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      isScript: isSet(object.isScript) ? globalThis.Boolean(object.isScript) : false,
      isCreate: isSet(object.isCreate) ? globalThis.Boolean(object.isCreate) : false,
      isMint: isSet(object.isMint) ? globalThis.Boolean(object.isMint) : false,
      isUpgrade: isSet(object.isUpgrade) ? globalThis.Boolean(object.isUpgrade) : false,
      isUpload: isSet(object.isUpload) ? globalThis.Boolean(object.isUpload) : false,
      isBlob: isSet(object.isBlob) ? globalThis.Boolean(object.isBlob) : false,
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => Output.fromJSON(e)) : [],
      outputContract: isSet(object.outputContract) ? OutputContract.fromJSON(object.outputContract) : undefined,
      mintAmount: isSet(object.mintAmount) ? globalThis.Number(object.mintAmount) : 0,
      mintAssetId: isSet(object.mintAssetId) ? bytesFromBase64(object.mintAssetId) : new Uint8Array(0),
      mintGasPrice: isSet(object.mintGasPrice) ? globalThis.Number(object.mintGasPrice) : 0,
      receiptsRoot: isSet(object.receiptsRoot) ? bytesFromBase64(object.receiptsRoot) : new Uint8Array(0),
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      witnesses: globalThis.Array.isArray(object?.witnesses)
        ? object.witnesses.map((e: any) => bytesFromBase64(e))
        : [],
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
      scriptData: isSet(object.scriptData) ? bytesFromBase64(object.scriptData) : new Uint8Array(0),
      policies: isSet(object.policies) ? Policy.fromJSON(object.policies) : undefined,
      salt: isSet(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(0),
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => bytesFromBase64(e))
        : [],
      bytecodeWitnessIndex: isSet(object.bytecodeWitnessIndex) ? globalThis.Number(object.bytecodeWitnessIndex) : 0,
      bytecodeRoot: isSet(object.bytecodeRoot) ? bytesFromBase64(object.bytecodeRoot) : new Uint8Array(0),
      subsectionIndex: isSet(object.subsectionIndex) ? globalThis.Number(object.subsectionIndex) : 0,
      subsectionsNumber: isSet(object.subsectionsNumber) ? globalThis.Number(object.subsectionsNumber) : 0,
      proofSet: globalThis.Array.isArray(object?.proofSet) ? object.proofSet.map((e: any) => bytesFromBase64(e)) : [],
      upgradePurpose: isSet(object.upgradePurpose) ? globalThis.Number(object.upgradePurpose) : 0,
      blobId: isSet(object.blobId) ? bytesFromBase64(object.blobId) : new Uint8Array(0),
      maturity: isSet(object.maturity) ? globalThis.Number(object.maturity) : 0,
      policyType: isSet(object.policyType) ? globalThis.Number(object.policyType) : 0,
      rawPayload: isSet(object.rawPayload) ? bytesFromBase64(object.rawPayload) : new Uint8Array(0),
      scriptLength: isSet(object.scriptLength) ? globalThis.Number(object.scriptLength) : 0,
      scriptDataLength: isSet(object.scriptDataLength) ? globalThis.Number(object.scriptDataLength) : 0,
      storageSlotsCount: isSet(object.storageSlotsCount) ? globalThis.Number(object.storageSlotsCount) : 0,
      proofSetCount: isSet(object.proofSetCount) ? globalThis.Number(object.proofSetCount) : 0,
      witnessesCount: isSet(object.witnessesCount) ? globalThis.Number(object.witnessesCount) : 0,
      inputsCount: isSet(object.inputsCount) ? globalThis.Number(object.inputsCount) : 0,
      outputsCount: isSet(object.outputsCount) ? globalThis.Number(object.outputsCount) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.scriptGasLimit !== 0) {
      obj.scriptGasLimit = Math.round(message.scriptGasLimit);
    }
    if (message.txPointer !== undefined) {
      obj.txPointer = TxPointer.toJSON(message.txPointer);
    }
    if (message.inputAssetIds?.length) {
      obj.inputAssetIds = message.inputAssetIds.map((e) => base64FromBytes(e));
    }
    if (message.inputContracts?.length) {
      obj.inputContracts = message.inputContracts.map((e) => base64FromBytes(e));
    }
    if (message.inputContract !== undefined) {
      obj.inputContract = InputContract.toJSON(message.inputContract);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.isScript !== false) {
      obj.isScript = message.isScript;
    }
    if (message.isCreate !== false) {
      obj.isCreate = message.isCreate;
    }
    if (message.isMint !== false) {
      obj.isMint = message.isMint;
    }
    if (message.isUpgrade !== false) {
      obj.isUpgrade = message.isUpgrade;
    }
    if (message.isUpload !== false) {
      obj.isUpload = message.isUpload;
    }
    if (message.isBlob !== false) {
      obj.isBlob = message.isBlob;
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => Output.toJSON(e));
    }
    if (message.outputContract !== undefined) {
      obj.outputContract = OutputContract.toJSON(message.outputContract);
    }
    if (message.mintAmount !== 0) {
      obj.mintAmount = Math.round(message.mintAmount);
    }
    if (message.mintAssetId.length !== 0) {
      obj.mintAssetId = base64FromBytes(message.mintAssetId);
    }
    if (message.mintGasPrice !== 0) {
      obj.mintGasPrice = Math.round(message.mintGasPrice);
    }
    if (message.receiptsRoot.length !== 0) {
      obj.receiptsRoot = base64FromBytes(message.receiptsRoot);
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.witnesses?.length) {
      obj.witnesses = message.witnesses.map((e) => base64FromBytes(e));
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    if (message.scriptData.length !== 0) {
      obj.scriptData = base64FromBytes(message.scriptData);
    }
    if (message.policies !== undefined) {
      obj.policies = Policy.toJSON(message.policies);
    }
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => base64FromBytes(e));
    }
    if (message.bytecodeWitnessIndex !== 0) {
      obj.bytecodeWitnessIndex = Math.round(message.bytecodeWitnessIndex);
    }
    if (message.bytecodeRoot.length !== 0) {
      obj.bytecodeRoot = base64FromBytes(message.bytecodeRoot);
    }
    if (message.subsectionIndex !== 0) {
      obj.subsectionIndex = Math.round(message.subsectionIndex);
    }
    if (message.subsectionsNumber !== 0) {
      obj.subsectionsNumber = Math.round(message.subsectionsNumber);
    }
    if (message.proofSet?.length) {
      obj.proofSet = message.proofSet.map((e) => base64FromBytes(e));
    }
    if (message.upgradePurpose !== 0) {
      obj.upgradePurpose = Math.round(message.upgradePurpose);
    }
    if (message.blobId.length !== 0) {
      obj.blobId = base64FromBytes(message.blobId);
    }
    if (message.maturity !== 0) {
      obj.maturity = Math.round(message.maturity);
    }
    if (message.policyType !== 0) {
      obj.policyType = Math.round(message.policyType);
    }
    if (message.rawPayload.length !== 0) {
      obj.rawPayload = base64FromBytes(message.rawPayload);
    }
    if (message.scriptLength !== 0) {
      obj.scriptLength = Math.round(message.scriptLength);
    }
    if (message.scriptDataLength !== 0) {
      obj.scriptDataLength = Math.round(message.scriptDataLength);
    }
    if (message.storageSlotsCount !== 0) {
      obj.storageSlotsCount = Math.round(message.storageSlotsCount);
    }
    if (message.proofSetCount !== 0) {
      obj.proofSetCount = Math.round(message.proofSetCount);
    }
    if (message.witnessesCount !== 0) {
      obj.witnessesCount = Math.round(message.witnessesCount);
    }
    if (message.inputsCount !== 0) {
      obj.inputsCount = Math.round(message.inputsCount);
    }
    if (message.outputsCount !== 0) {
      obj.outputsCount = Math.round(message.outputsCount);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.subject = object.subject ?? "";
    message.id = object.id ?? new Uint8Array(0);
    message.scriptGasLimit = object.scriptGasLimit ?? 0;
    message.txPointer = (object.txPointer !== undefined && object.txPointer !== null)
      ? TxPointer.fromPartial(object.txPointer)
      : undefined;
    message.inputAssetIds = object.inputAssetIds?.map((e) => e) || [];
    message.inputContracts = object.inputContracts?.map((e) => e) || [];
    message.inputContract = (object.inputContract !== undefined && object.inputContract !== null)
      ? InputContract.fromPartial(object.inputContract)
      : undefined;
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.isScript = object.isScript ?? false;
    message.isCreate = object.isCreate ?? false;
    message.isMint = object.isMint ?? false;
    message.isUpgrade = object.isUpgrade ?? false;
    message.isUpload = object.isUpload ?? false;
    message.isBlob = object.isBlob ?? false;
    message.outputs = object.outputs?.map((e) => Output.fromPartial(e)) || [];
    message.outputContract = (object.outputContract !== undefined && object.outputContract !== null)
      ? OutputContract.fromPartial(object.outputContract)
      : undefined;
    message.mintAmount = object.mintAmount ?? 0;
    message.mintAssetId = object.mintAssetId ?? new Uint8Array(0);
    message.mintGasPrice = object.mintGasPrice ?? 0;
    message.receiptsRoot = object.receiptsRoot ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.witnesses = object.witnesses?.map((e) => e) || [];
    message.script = object.script ?? new Uint8Array(0);
    message.scriptData = object.scriptData ?? new Uint8Array(0);
    message.policies = (object.policies !== undefined && object.policies !== null)
      ? Policy.fromPartial(object.policies)
      : undefined;
    message.salt = object.salt ?? new Uint8Array(0);
    message.storageSlots = object.storageSlots?.map((e) => e) || [];
    message.bytecodeWitnessIndex = object.bytecodeWitnessIndex ?? 0;
    message.bytecodeRoot = object.bytecodeRoot ?? new Uint8Array(0);
    message.subsectionIndex = object.subsectionIndex ?? 0;
    message.subsectionsNumber = object.subsectionsNumber ?? 0;
    message.proofSet = object.proofSet?.map((e) => e) || [];
    message.upgradePurpose = object.upgradePurpose ?? 0;
    message.blobId = object.blobId ?? new Uint8Array(0);
    message.maturity = object.maturity ?? 0;
    message.policyType = object.policyType ?? 0;
    message.rawPayload = object.rawPayload ?? new Uint8Array(0);
    message.scriptLength = object.scriptLength ?? 0;
    message.scriptDataLength = object.scriptDataLength ?? 0;
    message.storageSlotsCount = object.storageSlotsCount ?? 0;
    message.proofSetCount = object.proofSetCount ?? 0;
    message.witnessesCount = object.witnessesCount ?? 0;
    message.inputsCount = object.inputsCount ?? 0;
    message.outputsCount = object.outputsCount ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseStorageSlot(): StorageSlot {
  return { subject: "", txId: new Uint8Array(0), key: new Uint8Array(0), value: new Uint8Array(0) };
}

export const StorageSlot: MessageFns<StorageSlot> = {
  encode(message: StorageSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.key.length !== 0) {
      writer.uint32(26).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(34).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlot {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: StorageSlot): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlot>, I>>(base?: I): StorageSlot {
    return StorageSlot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlot>, I>>(object: I): StorageSlot {
    const message = createBaseStorageSlot();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.key = object.key ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWitness(): Witness {
  return { subject: "", txId: new Uint8Array(0), witnessData: new Uint8Array(0), witnessDataLength: 0 };
}

export const Witness: MessageFns<Witness> = {
  encode(message: Witness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.witnessData.length !== 0) {
      writer.uint32(26).bytes(message.witnessData);
    }
    if (message.witnessDataLength !== 0) {
      writer.uint32(32).int32(message.witnessDataLength);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Witness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.witnessData = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.witnessDataLength = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Witness {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      witnessData: isSet(object.witnessData) ? bytesFromBase64(object.witnessData) : new Uint8Array(0),
      witnessDataLength: isSet(object.witnessDataLength) ? globalThis.Number(object.witnessDataLength) : 0,
    };
  },

  toJSON(message: Witness): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.witnessData.length !== 0) {
      obj.witnessData = base64FromBytes(message.witnessData);
    }
    if (message.witnessDataLength !== 0) {
      obj.witnessDataLength = Math.round(message.witnessDataLength);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Witness>, I>>(base?: I): Witness {
    return Witness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Witness>, I>>(object: I): Witness {
    const message = createBaseWitness();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.witnessData = object.witnessData ?? new Uint8Array(0);
    message.witnessDataLength = object.witnessDataLength ?? 0;
    return message;
  },
};

function createBaseProofSet(): ProofSet {
  return { subject: "", txId: new Uint8Array(0), proofHash: new Uint8Array(0) };
}

export const ProofSet: MessageFns<ProofSet> = {
  encode(message: ProofSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.proofHash.length !== 0) {
      writer.uint32(26).bytes(message.proofHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proofHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofSet {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      proofHash: isSet(object.proofHash) ? bytesFromBase64(object.proofHash) : new Uint8Array(0),
    };
  },

  toJSON(message: ProofSet): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.proofHash.length !== 0) {
      obj.proofHash = base64FromBytes(message.proofHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofSet>, I>>(base?: I): ProofSet {
    return ProofSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofSet>, I>>(object: I): ProofSet {
    const message = createBaseProofSet();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.proofHash = object.proofHash ?? new Uint8Array(0);
    return message;
  },
};

function createBasePolicy(): Policy {
  return { subject: "", txId: new Uint8Array(0), type: 0, data: 0 };
}

export const Policy: MessageFns<Policy> = {
  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.data !== 0) {
      writer.uint32(32).int64(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.data = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      type: isSet(object.type) ? policyTypeFromJSON(object.type) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.type !== 0) {
      obj.type = policyTypeToJSON(message.type);
    }
    if (message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policy>, I>>(base?: I): Policy {
    return Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policy>, I>>(object: I): Policy {
    const message = createBasePolicy();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.type = object.type ?? 0;
    message.data = object.data ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
