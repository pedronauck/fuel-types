// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: receipts.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";
import { ReceiptPointer } from "./pointers";

export const protobufPackage = "receipts";

export enum ReceiptType {
  CALL = 0,
  RETURN = 1,
  RETURN_DATA = 2,
  PANIC = 3,
  REVERT = 4,
  LOG = 5,
  LOG_DATA = 6,
  TRANSFER = 7,
  TRANSFER_OUT = 8,
  SCRIPT_RESULT = 9,
  MESSAGE_OUT = 10,
  MINT = 11,
  BURN = 12,
  UNRECOGNIZED = -1,
}

export function receiptTypeFromJSON(object: any): ReceiptType {
  switch (object) {
    case 0:
    case "CALL":
      return ReceiptType.CALL;
    case 1:
    case "RETURN":
      return ReceiptType.RETURN;
    case 2:
    case "RETURN_DATA":
      return ReceiptType.RETURN_DATA;
    case 3:
    case "PANIC":
      return ReceiptType.PANIC;
    case 4:
    case "REVERT":
      return ReceiptType.REVERT;
    case 5:
    case "LOG":
      return ReceiptType.LOG;
    case 6:
    case "LOG_DATA":
      return ReceiptType.LOG_DATA;
    case 7:
    case "TRANSFER":
      return ReceiptType.TRANSFER;
    case 8:
    case "TRANSFER_OUT":
      return ReceiptType.TRANSFER_OUT;
    case 9:
    case "SCRIPT_RESULT":
      return ReceiptType.SCRIPT_RESULT;
    case 10:
    case "MESSAGE_OUT":
      return ReceiptType.MESSAGE_OUT;
    case 11:
    case "MINT":
      return ReceiptType.MINT;
    case 12:
    case "BURN":
      return ReceiptType.BURN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReceiptType.UNRECOGNIZED;
  }
}

export function receiptTypeToJSON(object: ReceiptType): string {
  switch (object) {
    case ReceiptType.CALL:
      return "CALL";
    case ReceiptType.RETURN:
      return "RETURN";
    case ReceiptType.RETURN_DATA:
      return "RETURN_DATA";
    case ReceiptType.PANIC:
      return "PANIC";
    case ReceiptType.REVERT:
      return "REVERT";
    case ReceiptType.LOG:
      return "LOG";
    case ReceiptType.LOG_DATA:
      return "LOG_DATA";
    case ReceiptType.TRANSFER:
      return "TRANSFER";
    case ReceiptType.TRANSFER_OUT:
      return "TRANSFER_OUT";
    case ReceiptType.SCRIPT_RESULT:
      return "SCRIPT_RESULT";
    case ReceiptType.MESSAGE_OUT:
      return "MESSAGE_OUT";
    case ReceiptType.MINT:
      return "MINT";
    case ReceiptType.BURN:
      return "BURN";
    case ReceiptType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ScriptResultType {
  SUCCESS = 0,
  FAILURE = 1,
  UNRECOGNIZED = -1,
}

export function scriptResultTypeFromJSON(object: any): ScriptResultType {
  switch (object) {
    case 0:
    case "SUCCESS":
      return ScriptResultType.SUCCESS;
    case 1:
    case "FAILURE":
      return ScriptResultType.FAILURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScriptResultType.UNRECOGNIZED;
  }
}

export function scriptResultTypeToJSON(object: ScriptResultType): string {
  switch (object) {
    case ScriptResultType.SUCCESS:
      return "SUCCESS";
    case ScriptResultType.FAILURE:
      return "FAILURE";
    case ScriptResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Receipt {
  subject: string;
  blockHeight: number;
  txId: Uint8Array;
  txIndex: number;
  receiptIndex: number;
  receiptType: ReceiptType;
  call?: ReceiptCall | undefined;
  return?: ReceiptReturn | undefined;
  returnData?: ReceiptReturnData | undefined;
  panic?: ReceiptPanic | undefined;
  revert?: ReceiptRevert | undefined;
  log?: ReceiptLog | undefined;
  logData?: ReceiptLogData | undefined;
  transfer?: ReceiptTransfer | undefined;
  transferOut?: ReceiptTransferOut | undefined;
  scriptResult?: ReceiptScriptResult | undefined;
  messageOut?: ReceiptMessageOut | undefined;
  mint?: ReceiptMint | undefined;
  burn?:
    | ReceiptBurn
    | undefined;
  /** Metadata */
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
  pointer: ReceiptPointer | undefined;
}

export interface ReceiptCall {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  toContractId: Uint8Array;
  amount: number;
  assetId: Uint8Array;
  gas: number;
  param1: number;
  param2: number;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptReturn {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  val: number;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptReturnData {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  ptr: number;
  len: number;
  digest: Uint8Array;
  pc: number;
  is: number;
  data: Uint8Array;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptPanic {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  reason: number;
  pc: number;
  is: number;
  panicContractId: Uint8Array;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptRevert {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  val: number;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptLog {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  ra: number;
  rb: number;
  rc: number;
  rd: number;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptLogData {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  ra: number;
  rb: number;
  ptr: number;
  len: number;
  digest: Uint8Array;
  pc: number;
  is: number;
  data: Uint8Array;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptTransfer {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  toContractId: Uint8Array;
  amount: number;
  assetId: Uint8Array;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptTransferOut {
  subject: string;
  txId: Uint8Array;
  contractId: Uint8Array;
  toAddress: Uint8Array;
  amount: number;
  assetId: Uint8Array;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptScriptResult {
  subject: string;
  txId: Uint8Array;
  result: ScriptResultType;
  gasUsed: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptMessageOut {
  subject: string;
  txId: Uint8Array;
  senderAddress: Uint8Array;
  recipientAddress: Uint8Array;
  amount: number;
  nonce: Uint8Array;
  len: number;
  digest: Uint8Array;
  data: Uint8Array;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptMint {
  subject: string;
  txId: Uint8Array;
  subId: Uint8Array;
  contractId: Uint8Array;
  assetId: Uint8Array;
  val: number;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

export interface ReceiptBurn {
  subject: string;
  txId: Uint8Array;
  subId: Uint8Array;
  contractId: Uint8Array;
  assetId: Uint8Array;
  val: number;
  pc: number;
  is: number;
  createdAt: Date | undefined;
  publishedAt: Date | undefined;
}

function createBaseReceipt(): Receipt {
  return {
    subject: "",
    blockHeight: 0,
    txId: new Uint8Array(0),
    txIndex: 0,
    receiptIndex: 0,
    receiptType: 0,
    call: undefined,
    return: undefined,
    returnData: undefined,
    panic: undefined,
    revert: undefined,
    log: undefined,
    logData: undefined,
    transfer: undefined,
    transferOut: undefined,
    scriptResult: undefined,
    messageOut: undefined,
    mint: undefined,
    burn: undefined,
    createdAt: undefined,
    publishedAt: undefined,
    pointer: undefined,
  };
}

export const Receipt: MessageFns<Receipt> = {
  encode(message: Receipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(16).int64(message.blockHeight);
    }
    if (message.txId.length !== 0) {
      writer.uint32(26).bytes(message.txId);
    }
    if (message.txIndex !== 0) {
      writer.uint32(32).int32(message.txIndex);
    }
    if (message.receiptIndex !== 0) {
      writer.uint32(40).int32(message.receiptIndex);
    }
    if (message.receiptType !== 0) {
      writer.uint32(48).int32(message.receiptType);
    }
    if (message.call !== undefined) {
      ReceiptCall.encode(message.call, writer.uint32(58).fork()).join();
    }
    if (message.return !== undefined) {
      ReceiptReturn.encode(message.return, writer.uint32(66).fork()).join();
    }
    if (message.returnData !== undefined) {
      ReceiptReturnData.encode(message.returnData, writer.uint32(74).fork()).join();
    }
    if (message.panic !== undefined) {
      ReceiptPanic.encode(message.panic, writer.uint32(82).fork()).join();
    }
    if (message.revert !== undefined) {
      ReceiptRevert.encode(message.revert, writer.uint32(90).fork()).join();
    }
    if (message.log !== undefined) {
      ReceiptLog.encode(message.log, writer.uint32(98).fork()).join();
    }
    if (message.logData !== undefined) {
      ReceiptLogData.encode(message.logData, writer.uint32(106).fork()).join();
    }
    if (message.transfer !== undefined) {
      ReceiptTransfer.encode(message.transfer, writer.uint32(114).fork()).join();
    }
    if (message.transferOut !== undefined) {
      ReceiptTransferOut.encode(message.transferOut, writer.uint32(122).fork()).join();
    }
    if (message.scriptResult !== undefined) {
      ReceiptScriptResult.encode(message.scriptResult, writer.uint32(130).fork()).join();
    }
    if (message.messageOut !== undefined) {
      ReceiptMessageOut.encode(message.messageOut, writer.uint32(138).fork()).join();
    }
    if (message.mint !== undefined) {
      ReceiptMint.encode(message.mint, writer.uint32(146).fork()).join();
    }
    if (message.burn !== undefined) {
      ReceiptBurn.encode(message.burn, writer.uint32(154).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(162).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(170).fork()).join();
    }
    if (message.pointer !== undefined) {
      ReceiptPointer.encode(message.pointer, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.txIndex = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.receiptIndex = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.receiptType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.call = ReceiptCall.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.return = ReceiptReturn.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.returnData = ReceiptReturnData.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.panic = ReceiptPanic.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.revert = ReceiptRevert.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.log = ReceiptLog.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.logData = ReceiptLogData.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.transfer = ReceiptTransfer.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.transferOut = ReceiptTransferOut.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.scriptResult = ReceiptScriptResult.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.messageOut = ReceiptMessageOut.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.mint = ReceiptMint.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.burn = ReceiptBurn.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.pointer = ReceiptPointer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      blockHeight: isSet(object.blockHeight) ? globalThis.Number(object.blockHeight) : 0,
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      txIndex: isSet(object.txIndex) ? globalThis.Number(object.txIndex) : 0,
      receiptIndex: isSet(object.receiptIndex) ? globalThis.Number(object.receiptIndex) : 0,
      receiptType: isSet(object.receiptType) ? receiptTypeFromJSON(object.receiptType) : 0,
      call: isSet(object.call) ? ReceiptCall.fromJSON(object.call) : undefined,
      return: isSet(object.return) ? ReceiptReturn.fromJSON(object.return) : undefined,
      returnData: isSet(object.returnData) ? ReceiptReturnData.fromJSON(object.returnData) : undefined,
      panic: isSet(object.panic) ? ReceiptPanic.fromJSON(object.panic) : undefined,
      revert: isSet(object.revert) ? ReceiptRevert.fromJSON(object.revert) : undefined,
      log: isSet(object.log) ? ReceiptLog.fromJSON(object.log) : undefined,
      logData: isSet(object.logData) ? ReceiptLogData.fromJSON(object.logData) : undefined,
      transfer: isSet(object.transfer) ? ReceiptTransfer.fromJSON(object.transfer) : undefined,
      transferOut: isSet(object.transferOut) ? ReceiptTransferOut.fromJSON(object.transferOut) : undefined,
      scriptResult: isSet(object.scriptResult) ? ReceiptScriptResult.fromJSON(object.scriptResult) : undefined,
      messageOut: isSet(object.messageOut) ? ReceiptMessageOut.fromJSON(object.messageOut) : undefined,
      mint: isSet(object.mint) ? ReceiptMint.fromJSON(object.mint) : undefined,
      burn: isSet(object.burn) ? ReceiptBurn.fromJSON(object.burn) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
      pointer: isSet(object.pointer) ? ReceiptPointer.fromJSON(object.pointer) : undefined,
    };
  },

  toJSON(message: Receipt): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.txIndex !== 0) {
      obj.txIndex = Math.round(message.txIndex);
    }
    if (message.receiptIndex !== 0) {
      obj.receiptIndex = Math.round(message.receiptIndex);
    }
    if (message.receiptType !== 0) {
      obj.receiptType = receiptTypeToJSON(message.receiptType);
    }
    if (message.call !== undefined) {
      obj.call = ReceiptCall.toJSON(message.call);
    }
    if (message.return !== undefined) {
      obj.return = ReceiptReturn.toJSON(message.return);
    }
    if (message.returnData !== undefined) {
      obj.returnData = ReceiptReturnData.toJSON(message.returnData);
    }
    if (message.panic !== undefined) {
      obj.panic = ReceiptPanic.toJSON(message.panic);
    }
    if (message.revert !== undefined) {
      obj.revert = ReceiptRevert.toJSON(message.revert);
    }
    if (message.log !== undefined) {
      obj.log = ReceiptLog.toJSON(message.log);
    }
    if (message.logData !== undefined) {
      obj.logData = ReceiptLogData.toJSON(message.logData);
    }
    if (message.transfer !== undefined) {
      obj.transfer = ReceiptTransfer.toJSON(message.transfer);
    }
    if (message.transferOut !== undefined) {
      obj.transferOut = ReceiptTransferOut.toJSON(message.transferOut);
    }
    if (message.scriptResult !== undefined) {
      obj.scriptResult = ReceiptScriptResult.toJSON(message.scriptResult);
    }
    if (message.messageOut !== undefined) {
      obj.messageOut = ReceiptMessageOut.toJSON(message.messageOut);
    }
    if (message.mint !== undefined) {
      obj.mint = ReceiptMint.toJSON(message.mint);
    }
    if (message.burn !== undefined) {
      obj.burn = ReceiptBurn.toJSON(message.burn);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    if (message.pointer !== undefined) {
      obj.pointer = ReceiptPointer.toJSON(message.pointer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt>, I>>(base?: I): Receipt {
    return Receipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt>, I>>(object: I): Receipt {
    const message = createBaseReceipt();
    message.subject = object.subject ?? "";
    message.blockHeight = object.blockHeight ?? 0;
    message.txId = object.txId ?? new Uint8Array(0);
    message.txIndex = object.txIndex ?? 0;
    message.receiptIndex = object.receiptIndex ?? 0;
    message.receiptType = object.receiptType ?? 0;
    message.call = (object.call !== undefined && object.call !== null)
      ? ReceiptCall.fromPartial(object.call)
      : undefined;
    message.return = (object.return !== undefined && object.return !== null)
      ? ReceiptReturn.fromPartial(object.return)
      : undefined;
    message.returnData = (object.returnData !== undefined && object.returnData !== null)
      ? ReceiptReturnData.fromPartial(object.returnData)
      : undefined;
    message.panic = (object.panic !== undefined && object.panic !== null)
      ? ReceiptPanic.fromPartial(object.panic)
      : undefined;
    message.revert = (object.revert !== undefined && object.revert !== null)
      ? ReceiptRevert.fromPartial(object.revert)
      : undefined;
    message.log = (object.log !== undefined && object.log !== null) ? ReceiptLog.fromPartial(object.log) : undefined;
    message.logData = (object.logData !== undefined && object.logData !== null)
      ? ReceiptLogData.fromPartial(object.logData)
      : undefined;
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? ReceiptTransfer.fromPartial(object.transfer)
      : undefined;
    message.transferOut = (object.transferOut !== undefined && object.transferOut !== null)
      ? ReceiptTransferOut.fromPartial(object.transferOut)
      : undefined;
    message.scriptResult = (object.scriptResult !== undefined && object.scriptResult !== null)
      ? ReceiptScriptResult.fromPartial(object.scriptResult)
      : undefined;
    message.messageOut = (object.messageOut !== undefined && object.messageOut !== null)
      ? ReceiptMessageOut.fromPartial(object.messageOut)
      : undefined;
    message.mint = (object.mint !== undefined && object.mint !== null)
      ? ReceiptMint.fromPartial(object.mint)
      : undefined;
    message.burn = (object.burn !== undefined && object.burn !== null)
      ? ReceiptBurn.fromPartial(object.burn)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    message.pointer = (object.pointer !== undefined && object.pointer !== null)
      ? ReceiptPointer.fromPartial(object.pointer)
      : undefined;
    return message;
  },
};

function createBaseReceiptCall(): ReceiptCall {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    toContractId: new Uint8Array(0),
    amount: 0,
    assetId: new Uint8Array(0),
    gas: 0,
    param1: 0,
    param2: 0,
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptCall: MessageFns<ReceiptCall> = {
  encode(message: ReceiptCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.toContractId.length !== 0) {
      writer.uint32(34).bytes(message.toContractId);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(50).bytes(message.assetId);
    }
    if (message.gas !== 0) {
      writer.uint32(56).int64(message.gas);
    }
    if (message.param1 !== 0) {
      writer.uint32(64).int64(message.param1);
    }
    if (message.param2 !== 0) {
      writer.uint32(72).int64(message.param2);
    }
    if (message.pc !== 0) {
      writer.uint32(80).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(88).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toContractId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gas = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.param1 = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.param2 = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptCall {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      toContractId: isSet(object.toContractId) ? bytesFromBase64(object.toContractId) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      param1: isSet(object.param1) ? globalThis.Number(object.param1) : 0,
      param2: isSet(object.param2) ? globalThis.Number(object.param2) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptCall): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.toContractId.length !== 0) {
      obj.toContractId = base64FromBytes(message.toContractId);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.param1 !== 0) {
      obj.param1 = Math.round(message.param1);
    }
    if (message.param2 !== 0) {
      obj.param2 = Math.round(message.param2);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptCall>, I>>(base?: I): ReceiptCall {
    return ReceiptCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptCall>, I>>(object: I): ReceiptCall {
    const message = createBaseReceiptCall();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.toContractId = object.toContractId ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.gas = object.gas ?? 0;
    message.param1 = object.param1 ?? 0;
    message.param2 = object.param2 ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptReturn(): ReceiptReturn {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    val: 0,
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptReturn: MessageFns<ReceiptReturn> = {
  encode(message: ReceiptReturn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.val !== 0) {
      writer.uint32(32).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptReturn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptReturn {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptReturn): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptReturn>, I>>(base?: I): ReceiptReturn {
    return ReceiptReturn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptReturn>, I>>(object: I): ReceiptReturn {
    const message = createBaseReceiptReturn();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptReturnData(): ReceiptReturnData {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    ptr: 0,
    len: 0,
    digest: new Uint8Array(0),
    pc: 0,
    is: 0,
    data: new Uint8Array(0),
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptReturnData: MessageFns<ReceiptReturnData> = {
  encode(message: ReceiptReturnData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.ptr !== 0) {
      writer.uint32(32).int64(message.ptr);
    }
    if (message.len !== 0) {
      writer.uint32(40).int64(message.len);
    }
    if (message.digest.length !== 0) {
      writer.uint32(50).bytes(message.digest);
    }
    if (message.pc !== 0) {
      writer.uint32(56).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(64).int64(message.is);
    }
    if (message.data.length !== 0) {
      writer.uint32(74).bytes(message.data);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptReturnData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptReturnData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ptr = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.len = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptReturnData {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      ptr: isSet(object.ptr) ? globalThis.Number(object.ptr) : 0,
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptReturnData): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.ptr !== 0) {
      obj.ptr = Math.round(message.ptr);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptReturnData>, I>>(base?: I): ReceiptReturnData {
    return ReceiptReturnData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptReturnData>, I>>(object: I): ReceiptReturnData {
    const message = createBaseReceiptReturnData();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.ptr = object.ptr ?? 0;
    message.len = object.len ?? 0;
    message.digest = object.digest ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptPanic(): ReceiptPanic {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    reason: 0,
    pc: 0,
    is: 0,
    panicContractId: new Uint8Array(0),
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptPanic: MessageFns<ReceiptPanic> = {
  encode(message: ReceiptPanic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.reason !== 0) {
      writer.uint32(32).int64(message.reason);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    if (message.panicContractId.length !== 0) {
      writer.uint32(58).bytes(message.panicContractId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptPanic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptPanic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reason = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.panicContractId = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptPanic {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      reason: isSet(object.reason) ? globalThis.Number(object.reason) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      panicContractId: isSet(object.panicContractId) ? bytesFromBase64(object.panicContractId) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptPanic): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.reason !== 0) {
      obj.reason = Math.round(message.reason);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.panicContractId.length !== 0) {
      obj.panicContractId = base64FromBytes(message.panicContractId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptPanic>, I>>(base?: I): ReceiptPanic {
    return ReceiptPanic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptPanic>, I>>(object: I): ReceiptPanic {
    const message = createBaseReceiptPanic();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.reason = object.reason ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.panicContractId = object.panicContractId ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptRevert(): ReceiptRevert {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    val: 0,
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptRevert: MessageFns<ReceiptRevert> = {
  encode(message: ReceiptRevert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.val !== 0) {
      writer.uint32(32).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptRevert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptRevert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptRevert {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptRevert): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptRevert>, I>>(base?: I): ReceiptRevert {
    return ReceiptRevert.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptRevert>, I>>(object: I): ReceiptRevert {
    const message = createBaseReceiptRevert();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptLog(): ReceiptLog {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    ra: 0,
    rb: 0,
    rc: 0,
    rd: 0,
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptLog: MessageFns<ReceiptLog> = {
  encode(message: ReceiptLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.ra !== 0) {
      writer.uint32(32).int64(message.ra);
    }
    if (message.rb !== 0) {
      writer.uint32(40).int64(message.rb);
    }
    if (message.rc !== 0) {
      writer.uint32(48).int64(message.rc);
    }
    if (message.rd !== 0) {
      writer.uint32(56).int64(message.rd);
    }
    if (message.pc !== 0) {
      writer.uint32(64).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(72).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ra = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rb = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rc = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rd = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptLog {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      ra: isSet(object.ra) ? globalThis.Number(object.ra) : 0,
      rb: isSet(object.rb) ? globalThis.Number(object.rb) : 0,
      rc: isSet(object.rc) ? globalThis.Number(object.rc) : 0,
      rd: isSet(object.rd) ? globalThis.Number(object.rd) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptLog): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.ra !== 0) {
      obj.ra = Math.round(message.ra);
    }
    if (message.rb !== 0) {
      obj.rb = Math.round(message.rb);
    }
    if (message.rc !== 0) {
      obj.rc = Math.round(message.rc);
    }
    if (message.rd !== 0) {
      obj.rd = Math.round(message.rd);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptLog>, I>>(base?: I): ReceiptLog {
    return ReceiptLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptLog>, I>>(object: I): ReceiptLog {
    const message = createBaseReceiptLog();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.ra = object.ra ?? 0;
    message.rb = object.rb ?? 0;
    message.rc = object.rc ?? 0;
    message.rd = object.rd ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptLogData(): ReceiptLogData {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    ra: 0,
    rb: 0,
    ptr: 0,
    len: 0,
    digest: new Uint8Array(0),
    pc: 0,
    is: 0,
    data: new Uint8Array(0),
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptLogData: MessageFns<ReceiptLogData> = {
  encode(message: ReceiptLogData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.ra !== 0) {
      writer.uint32(32).int64(message.ra);
    }
    if (message.rb !== 0) {
      writer.uint32(40).int64(message.rb);
    }
    if (message.ptr !== 0) {
      writer.uint32(48).int64(message.ptr);
    }
    if (message.len !== 0) {
      writer.uint32(56).int64(message.len);
    }
    if (message.digest.length !== 0) {
      writer.uint32(66).bytes(message.digest);
    }
    if (message.pc !== 0) {
      writer.uint32(72).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(80).int64(message.is);
    }
    if (message.data.length !== 0) {
      writer.uint32(90).bytes(message.data);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptLogData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptLogData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ra = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rb = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ptr = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.len = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptLogData {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      ra: isSet(object.ra) ? globalThis.Number(object.ra) : 0,
      rb: isSet(object.rb) ? globalThis.Number(object.rb) : 0,
      ptr: isSet(object.ptr) ? globalThis.Number(object.ptr) : 0,
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptLogData): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.ra !== 0) {
      obj.ra = Math.round(message.ra);
    }
    if (message.rb !== 0) {
      obj.rb = Math.round(message.rb);
    }
    if (message.ptr !== 0) {
      obj.ptr = Math.round(message.ptr);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptLogData>, I>>(base?: I): ReceiptLogData {
    return ReceiptLogData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptLogData>, I>>(object: I): ReceiptLogData {
    const message = createBaseReceiptLogData();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.ra = object.ra ?? 0;
    message.rb = object.rb ?? 0;
    message.ptr = object.ptr ?? 0;
    message.len = object.len ?? 0;
    message.digest = object.digest ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptTransfer(): ReceiptTransfer {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    toContractId: new Uint8Array(0),
    amount: 0,
    assetId: new Uint8Array(0),
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptTransfer: MessageFns<ReceiptTransfer> = {
  encode(message: ReceiptTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.toContractId.length !== 0) {
      writer.uint32(34).bytes(message.toContractId);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(50).bytes(message.assetId);
    }
    if (message.pc !== 0) {
      writer.uint32(56).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(64).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toContractId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptTransfer {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      toContractId: isSet(object.toContractId) ? bytesFromBase64(object.toContractId) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptTransfer): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.toContractId.length !== 0) {
      obj.toContractId = base64FromBytes(message.toContractId);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptTransfer>, I>>(base?: I): ReceiptTransfer {
    return ReceiptTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptTransfer>, I>>(object: I): ReceiptTransfer {
    const message = createBaseReceiptTransfer();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.toContractId = object.toContractId ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptTransferOut(): ReceiptTransferOut {
  return {
    subject: "",
    txId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    toAddress: new Uint8Array(0),
    amount: 0,
    assetId: new Uint8Array(0),
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptTransferOut: MessageFns<ReceiptTransferOut> = {
  encode(message: ReceiptTransferOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(26).bytes(message.contractId);
    }
    if (message.toAddress.length !== 0) {
      writer.uint32(34).bytes(message.toAddress);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(50).bytes(message.assetId);
    }
    if (message.pc !== 0) {
      writer.uint32(56).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(64).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptTransferOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptTransferOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toAddress = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptTransferOut {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      toAddress: isSet(object.toAddress) ? bytesFromBase64(object.toAddress) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptTransferOut): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.toAddress.length !== 0) {
      obj.toAddress = base64FromBytes(message.toAddress);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptTransferOut>, I>>(base?: I): ReceiptTransferOut {
    return ReceiptTransferOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptTransferOut>, I>>(object: I): ReceiptTransferOut {
    const message = createBaseReceiptTransferOut();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.toAddress = object.toAddress ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptScriptResult(): ReceiptScriptResult {
  return { subject: "", txId: new Uint8Array(0), result: 0, gasUsed: 0, createdAt: undefined, publishedAt: undefined };
}

export const ReceiptScriptResult: MessageFns<ReceiptScriptResult> = {
  encode(message: ReceiptScriptResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.result !== 0) {
      writer.uint32(24).int32(message.result);
    }
    if (message.gasUsed !== 0) {
      writer.uint32(32).int64(message.gasUsed);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptScriptResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptScriptResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gasUsed = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptScriptResult {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      result: isSet(object.result) ? scriptResultTypeFromJSON(object.result) : 0,
      gasUsed: isSet(object.gasUsed) ? globalThis.Number(object.gasUsed) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptScriptResult): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.result !== 0) {
      obj.result = scriptResultTypeToJSON(message.result);
    }
    if (message.gasUsed !== 0) {
      obj.gasUsed = Math.round(message.gasUsed);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptScriptResult>, I>>(base?: I): ReceiptScriptResult {
    return ReceiptScriptResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptScriptResult>, I>>(object: I): ReceiptScriptResult {
    const message = createBaseReceiptScriptResult();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.result = object.result ?? 0;
    message.gasUsed = object.gasUsed ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptMessageOut(): ReceiptMessageOut {
  return {
    subject: "",
    txId: new Uint8Array(0),
    senderAddress: new Uint8Array(0),
    recipientAddress: new Uint8Array(0),
    amount: 0,
    nonce: new Uint8Array(0),
    len: 0,
    digest: new Uint8Array(0),
    data: new Uint8Array(0),
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptMessageOut: MessageFns<ReceiptMessageOut> = {
  encode(message: ReceiptMessageOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.senderAddress.length !== 0) {
      writer.uint32(26).bytes(message.senderAddress);
    }
    if (message.recipientAddress.length !== 0) {
      writer.uint32(34).bytes(message.recipientAddress);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(50).bytes(message.nonce);
    }
    if (message.len !== 0) {
      writer.uint32(56).int64(message.len);
    }
    if (message.digest.length !== 0) {
      writer.uint32(66).bytes(message.digest);
    }
    if (message.data.length !== 0) {
      writer.uint32(74).bytes(message.data);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptMessageOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptMessageOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.senderAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recipientAddress = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.len = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptMessageOut {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      senderAddress: isSet(object.senderAddress) ? bytesFromBase64(object.senderAddress) : new Uint8Array(0),
      recipientAddress: isSet(object.recipientAddress) ? bytesFromBase64(object.recipientAddress) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptMessageOut): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.senderAddress.length !== 0) {
      obj.senderAddress = base64FromBytes(message.senderAddress);
    }
    if (message.recipientAddress.length !== 0) {
      obj.recipientAddress = base64FromBytes(message.recipientAddress);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptMessageOut>, I>>(base?: I): ReceiptMessageOut {
    return ReceiptMessageOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptMessageOut>, I>>(object: I): ReceiptMessageOut {
    const message = createBaseReceiptMessageOut();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.senderAddress = object.senderAddress ?? new Uint8Array(0);
    message.recipientAddress = object.recipientAddress ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.len = object.len ?? 0;
    message.digest = object.digest ?? new Uint8Array(0);
    message.data = object.data ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptMint(): ReceiptMint {
  return {
    subject: "",
    txId: new Uint8Array(0),
    subId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    assetId: new Uint8Array(0),
    val: 0,
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptMint: MessageFns<ReceiptMint> = {
  encode(message: ReceiptMint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.subId.length !== 0) {
      writer.uint32(26).bytes(message.subId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(34).bytes(message.contractId);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(42).bytes(message.assetId);
    }
    if (message.val !== 0) {
      writer.uint32(48).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(56).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(64).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptMint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptMint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptMint {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      subId: isSet(object.subId) ? bytesFromBase64(object.subId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptMint): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.subId.length !== 0) {
      obj.subId = base64FromBytes(message.subId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptMint>, I>>(base?: I): ReceiptMint {
    return ReceiptMint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptMint>, I>>(object: I): ReceiptMint {
    const message = createBaseReceiptMint();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.subId = object.subId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBaseReceiptBurn(): ReceiptBurn {
  return {
    subject: "",
    txId: new Uint8Array(0),
    subId: new Uint8Array(0),
    contractId: new Uint8Array(0),
    assetId: new Uint8Array(0),
    val: 0,
    pc: 0,
    is: 0,
    createdAt: undefined,
    publishedAt: undefined,
  };
}

export const ReceiptBurn: MessageFns<ReceiptBurn> = {
  encode(message: ReceiptBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (message.subId.length !== 0) {
      writer.uint32(26).bytes(message.subId);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(34).bytes(message.contractId);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(42).bytes(message.assetId);
    }
    if (message.val !== 0) {
      writer.uint32(48).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(56).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(64).int64(message.is);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptBurn {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      txId: isSet(object.txId) ? bytesFromBase64(object.txId) : new Uint8Array(0),
      subId: isSet(object.subId) ? bytesFromBase64(object.subId) : new Uint8Array(0),
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: ReceiptBurn): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.subId.length !== 0) {
      obj.subId = base64FromBytes(message.subId);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptBurn>, I>>(base?: I): ReceiptBurn {
    return ReceiptBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptBurn>, I>>(object: I): ReceiptBurn {
    const message = createBaseReceiptBurn();
    message.subject = object.subject ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    message.subId = object.subId ?? new Uint8Array(0);
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
