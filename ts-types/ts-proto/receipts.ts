// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: receipts.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "./common";
import { ReceiptPointer } from "./pointers";

export const protobufPackage = "receipts";

export enum ReceiptType {
  UNKNOWN_RECEIPT_TYPE = 0,
  CALL = 1,
  RETURN = 2,
  RETURN_DATA = 3,
  PANIC = 4,
  REVERT = 5,
  LOG = 6,
  LOG_DATA = 7,
  TRANSFER = 8,
  TRANSFER_OUT = 9,
  SCRIPT_RESULT = 10,
  MESSAGE_OUT = 11,
  MINT = 12,
  BURN = 13,
  UNRECOGNIZED = -1,
}

export function receiptTypeFromJSON(object: any): ReceiptType {
  switch (object) {
    case 0:
    case "UNKNOWN_RECEIPT_TYPE":
      return ReceiptType.UNKNOWN_RECEIPT_TYPE;
    case 1:
    case "CALL":
      return ReceiptType.CALL;
    case 2:
    case "RETURN":
      return ReceiptType.RETURN;
    case 3:
    case "RETURN_DATA":
      return ReceiptType.RETURN_DATA;
    case 4:
    case "PANIC":
      return ReceiptType.PANIC;
    case 5:
    case "REVERT":
      return ReceiptType.REVERT;
    case 6:
    case "LOG":
      return ReceiptType.LOG;
    case 7:
    case "LOG_DATA":
      return ReceiptType.LOG_DATA;
    case 8:
    case "TRANSFER":
      return ReceiptType.TRANSFER;
    case 9:
    case "TRANSFER_OUT":
      return ReceiptType.TRANSFER_OUT;
    case 10:
    case "SCRIPT_RESULT":
      return ReceiptType.SCRIPT_RESULT;
    case 11:
    case "MESSAGE_OUT":
      return ReceiptType.MESSAGE_OUT;
    case 12:
    case "MINT":
      return ReceiptType.MINT;
    case 13:
    case "BURN":
      return ReceiptType.BURN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReceiptType.UNRECOGNIZED;
  }
}

export function receiptTypeToJSON(object: ReceiptType): string {
  switch (object) {
    case ReceiptType.UNKNOWN_RECEIPT_TYPE:
      return "UNKNOWN_RECEIPT_TYPE";
    case ReceiptType.CALL:
      return "CALL";
    case ReceiptType.RETURN:
      return "RETURN";
    case ReceiptType.RETURN_DATA:
      return "RETURN_DATA";
    case ReceiptType.PANIC:
      return "PANIC";
    case ReceiptType.REVERT:
      return "REVERT";
    case ReceiptType.LOG:
      return "LOG";
    case ReceiptType.LOG_DATA:
      return "LOG_DATA";
    case ReceiptType.TRANSFER:
      return "TRANSFER";
    case ReceiptType.TRANSFER_OUT:
      return "TRANSFER_OUT";
    case ReceiptType.SCRIPT_RESULT:
      return "SCRIPT_RESULT";
    case ReceiptType.MESSAGE_OUT:
      return "MESSAGE_OUT";
    case ReceiptType.MINT:
      return "MINT";
    case ReceiptType.BURN:
      return "BURN";
    case ReceiptType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ScriptResultType {
  UNKNOWN_SCRIPT_RESULT_TYPE = 0,
  SUCCESS = 1,
  SCRIPT_REVERT = 2,
  SCRIPT_PANIC = 3,
  GENERIC_FAILURE = 4,
  UNRECOGNIZED = -1,
}

export function scriptResultTypeFromJSON(object: any): ScriptResultType {
  switch (object) {
    case 0:
    case "UNKNOWN_SCRIPT_RESULT_TYPE":
      return ScriptResultType.UNKNOWN_SCRIPT_RESULT_TYPE;
    case 1:
    case "SUCCESS":
      return ScriptResultType.SUCCESS;
    case 2:
    case "SCRIPT_REVERT":
      return ScriptResultType.SCRIPT_REVERT;
    case 3:
    case "SCRIPT_PANIC":
      return ScriptResultType.SCRIPT_PANIC;
    case 4:
    case "GENERIC_FAILURE":
      return ScriptResultType.GENERIC_FAILURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScriptResultType.UNRECOGNIZED;
  }
}

export function scriptResultTypeToJSON(object: ScriptResultType): string {
  switch (object) {
    case ScriptResultType.UNKNOWN_SCRIPT_RESULT_TYPE:
      return "UNKNOWN_SCRIPT_RESULT_TYPE";
    case ScriptResultType.SUCCESS:
      return "SUCCESS";
    case ScriptResultType.SCRIPT_REVERT:
      return "SCRIPT_REVERT";
    case ScriptResultType.SCRIPT_PANIC:
      return "SCRIPT_PANIC";
    case ScriptResultType.GENERIC_FAILURE:
      return "GENERIC_FAILURE";
    case ScriptResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Receipt {
  type: ReceiptType;
  pointer: ReceiptPointer | undefined;
  call?: ReceiptCall | undefined;
  return?: ReceiptReturn | undefined;
  returnData?: ReceiptReturnData | undefined;
  panic?: ReceiptPanic | undefined;
  revert?: ReceiptRevert | undefined;
  log?: ReceiptLog | undefined;
  logData?: ReceiptLogData | undefined;
  transfer?: ReceiptTransfer | undefined;
  transferOut?: ReceiptTransferOut | undefined;
  scriptResult?: ReceiptScriptResult | undefined;
  messageOut?: ReceiptMessageOut | undefined;
  mint?: ReceiptMint | undefined;
  burn?:
    | ReceiptBurn
    | undefined;
  /** Metadata */
  metadata: Metadata | undefined;
}

export interface ReceiptCall {
  id: Uint8Array;
  to: Uint8Array;
  amount: number;
  assetId: Uint8Array;
  gas: number;
  param1: number;
  param2: number;
  pc: number;
  is: number;
}

export interface ReceiptReturn {
  id: Uint8Array;
  val: number;
  pc: number;
  is: number;
}

export interface ReceiptReturnData {
  id: Uint8Array;
  ptr: number;
  len: number;
  digest: Uint8Array;
  data: Uint8Array;
  pc: number;
  is: number;
}

export interface ReceiptPanic {
  id: Uint8Array;
  reason: number;
  pc: number;
  is: number;
  contractId: Uint8Array;
}

export interface ReceiptRevert {
  id: Uint8Array;
  ra: number;
  pc: number;
  is: number;
}

export interface ReceiptLog {
  id: Uint8Array;
  ra: number;
  rb: number;
  rc: number;
  rd: number;
  pc: number;
  is: number;
}

export interface ReceiptLogData {
  id: Uint8Array;
  ra: number;
  rb: number;
  ptr: number;
  len: number;
  digest: Uint8Array;
  data: Uint8Array;
  pc: number;
  is: number;
}

export interface ReceiptTransfer {
  id: Uint8Array;
  to: Uint8Array;
  amount: number;
  assetId: Uint8Array;
  pc: number;
  is: number;
}

export interface ReceiptTransferOut {
  id: Uint8Array;
  toAddress: Uint8Array;
  amount: number;
  assetId: Uint8Array;
  pc: number;
  is: number;
}

export interface ReceiptScriptResult {
  result: ScriptResultType;
  gasUsed: number;
}

export interface ReceiptMessageOut {
  sender: Uint8Array;
  recipient: Uint8Array;
  amount: number;
  nonce: Uint8Array;
  len: number;
  digest: Uint8Array;
  data: Uint8Array;
}

export interface ReceiptMint {
  subId: Uint8Array;
  id: Uint8Array;
  assetId: Uint8Array;
  val: number;
  pc: number;
  is: number;
}

export interface ReceiptBurn {
  subId: Uint8Array;
  id: Uint8Array;
  assetId: Uint8Array;
  val: number;
  pc: number;
  is: number;
}

function createBaseReceipt(): Receipt {
  return {
    type: 0,
    pointer: undefined,
    call: undefined,
    return: undefined,
    returnData: undefined,
    panic: undefined,
    revert: undefined,
    log: undefined,
    logData: undefined,
    transfer: undefined,
    transferOut: undefined,
    scriptResult: undefined,
    messageOut: undefined,
    mint: undefined,
    burn: undefined,
    metadata: undefined,
  };
}

export const Receipt: MessageFns<Receipt> = {
  encode(message: Receipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.pointer !== undefined) {
      ReceiptPointer.encode(message.pointer, writer.uint32(18).fork()).join();
    }
    if (message.call !== undefined) {
      ReceiptCall.encode(message.call, writer.uint32(26).fork()).join();
    }
    if (message.return !== undefined) {
      ReceiptReturn.encode(message.return, writer.uint32(34).fork()).join();
    }
    if (message.returnData !== undefined) {
      ReceiptReturnData.encode(message.returnData, writer.uint32(42).fork()).join();
    }
    if (message.panic !== undefined) {
      ReceiptPanic.encode(message.panic, writer.uint32(50).fork()).join();
    }
    if (message.revert !== undefined) {
      ReceiptRevert.encode(message.revert, writer.uint32(58).fork()).join();
    }
    if (message.log !== undefined) {
      ReceiptLog.encode(message.log, writer.uint32(66).fork()).join();
    }
    if (message.logData !== undefined) {
      ReceiptLogData.encode(message.logData, writer.uint32(74).fork()).join();
    }
    if (message.transfer !== undefined) {
      ReceiptTransfer.encode(message.transfer, writer.uint32(82).fork()).join();
    }
    if (message.transferOut !== undefined) {
      ReceiptTransferOut.encode(message.transferOut, writer.uint32(90).fork()).join();
    }
    if (message.scriptResult !== undefined) {
      ReceiptScriptResult.encode(message.scriptResult, writer.uint32(98).fork()).join();
    }
    if (message.messageOut !== undefined) {
      ReceiptMessageOut.encode(message.messageOut, writer.uint32(106).fork()).join();
    }
    if (message.mint !== undefined) {
      ReceiptMint.encode(message.mint, writer.uint32(114).fork()).join();
    }
    if (message.burn !== undefined) {
      ReceiptBurn.encode(message.burn, writer.uint32(122).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pointer = ReceiptPointer.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.call = ReceiptCall.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.return = ReceiptReturn.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.returnData = ReceiptReturnData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.panic = ReceiptPanic.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.revert = ReceiptRevert.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.log = ReceiptLog.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.logData = ReceiptLogData.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.transfer = ReceiptTransfer.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.transferOut = ReceiptTransferOut.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.scriptResult = ReceiptScriptResult.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.messageOut = ReceiptMessageOut.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.mint = ReceiptMint.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.burn = ReceiptBurn.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt {
    return {
      type: isSet(object.type) ? receiptTypeFromJSON(object.type) : 0,
      pointer: isSet(object.pointer) ? ReceiptPointer.fromJSON(object.pointer) : undefined,
      call: isSet(object.call) ? ReceiptCall.fromJSON(object.call) : undefined,
      return: isSet(object.return) ? ReceiptReturn.fromJSON(object.return) : undefined,
      returnData: isSet(object.returnData) ? ReceiptReturnData.fromJSON(object.returnData) : undefined,
      panic: isSet(object.panic) ? ReceiptPanic.fromJSON(object.panic) : undefined,
      revert: isSet(object.revert) ? ReceiptRevert.fromJSON(object.revert) : undefined,
      log: isSet(object.log) ? ReceiptLog.fromJSON(object.log) : undefined,
      logData: isSet(object.logData) ? ReceiptLogData.fromJSON(object.logData) : undefined,
      transfer: isSet(object.transfer) ? ReceiptTransfer.fromJSON(object.transfer) : undefined,
      transferOut: isSet(object.transferOut) ? ReceiptTransferOut.fromJSON(object.transferOut) : undefined,
      scriptResult: isSet(object.scriptResult) ? ReceiptScriptResult.fromJSON(object.scriptResult) : undefined,
      messageOut: isSet(object.messageOut) ? ReceiptMessageOut.fromJSON(object.messageOut) : undefined,
      mint: isSet(object.mint) ? ReceiptMint.fromJSON(object.mint) : undefined,
      burn: isSet(object.burn) ? ReceiptBurn.fromJSON(object.burn) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Receipt): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = receiptTypeToJSON(message.type);
    }
    if (message.pointer !== undefined) {
      obj.pointer = ReceiptPointer.toJSON(message.pointer);
    }
    if (message.call !== undefined) {
      obj.call = ReceiptCall.toJSON(message.call);
    }
    if (message.return !== undefined) {
      obj.return = ReceiptReturn.toJSON(message.return);
    }
    if (message.returnData !== undefined) {
      obj.returnData = ReceiptReturnData.toJSON(message.returnData);
    }
    if (message.panic !== undefined) {
      obj.panic = ReceiptPanic.toJSON(message.panic);
    }
    if (message.revert !== undefined) {
      obj.revert = ReceiptRevert.toJSON(message.revert);
    }
    if (message.log !== undefined) {
      obj.log = ReceiptLog.toJSON(message.log);
    }
    if (message.logData !== undefined) {
      obj.logData = ReceiptLogData.toJSON(message.logData);
    }
    if (message.transfer !== undefined) {
      obj.transfer = ReceiptTransfer.toJSON(message.transfer);
    }
    if (message.transferOut !== undefined) {
      obj.transferOut = ReceiptTransferOut.toJSON(message.transferOut);
    }
    if (message.scriptResult !== undefined) {
      obj.scriptResult = ReceiptScriptResult.toJSON(message.scriptResult);
    }
    if (message.messageOut !== undefined) {
      obj.messageOut = ReceiptMessageOut.toJSON(message.messageOut);
    }
    if (message.mint !== undefined) {
      obj.mint = ReceiptMint.toJSON(message.mint);
    }
    if (message.burn !== undefined) {
      obj.burn = ReceiptBurn.toJSON(message.burn);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt>, I>>(base?: I): Receipt {
    return Receipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt>, I>>(object: I): Receipt {
    const message = createBaseReceipt();
    message.type = object.type ?? 0;
    message.pointer = (object.pointer !== undefined && object.pointer !== null)
      ? ReceiptPointer.fromPartial(object.pointer)
      : undefined;
    message.call = (object.call !== undefined && object.call !== null)
      ? ReceiptCall.fromPartial(object.call)
      : undefined;
    message.return = (object.return !== undefined && object.return !== null)
      ? ReceiptReturn.fromPartial(object.return)
      : undefined;
    message.returnData = (object.returnData !== undefined && object.returnData !== null)
      ? ReceiptReturnData.fromPartial(object.returnData)
      : undefined;
    message.panic = (object.panic !== undefined && object.panic !== null)
      ? ReceiptPanic.fromPartial(object.panic)
      : undefined;
    message.revert = (object.revert !== undefined && object.revert !== null)
      ? ReceiptRevert.fromPartial(object.revert)
      : undefined;
    message.log = (object.log !== undefined && object.log !== null) ? ReceiptLog.fromPartial(object.log) : undefined;
    message.logData = (object.logData !== undefined && object.logData !== null)
      ? ReceiptLogData.fromPartial(object.logData)
      : undefined;
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? ReceiptTransfer.fromPartial(object.transfer)
      : undefined;
    message.transferOut = (object.transferOut !== undefined && object.transferOut !== null)
      ? ReceiptTransferOut.fromPartial(object.transferOut)
      : undefined;
    message.scriptResult = (object.scriptResult !== undefined && object.scriptResult !== null)
      ? ReceiptScriptResult.fromPartial(object.scriptResult)
      : undefined;
    message.messageOut = (object.messageOut !== undefined && object.messageOut !== null)
      ? ReceiptMessageOut.fromPartial(object.messageOut)
      : undefined;
    message.mint = (object.mint !== undefined && object.mint !== null)
      ? ReceiptMint.fromPartial(object.mint)
      : undefined;
    message.burn = (object.burn !== undefined && object.burn !== null)
      ? ReceiptBurn.fromPartial(object.burn)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseReceiptCall(): ReceiptCall {
  return {
    id: new Uint8Array(0),
    to: new Uint8Array(0),
    amount: 0,
    assetId: new Uint8Array(0),
    gas: 0,
    param1: 0,
    param2: 0,
    pc: 0,
    is: 0,
  };
}

export const ReceiptCall: MessageFns<ReceiptCall> = {
  encode(message: ReceiptCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.to.length !== 0) {
      writer.uint32(18).bytes(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(34).bytes(message.assetId);
    }
    if (message.gas !== 0) {
      writer.uint32(40).int64(message.gas);
    }
    if (message.param1 !== 0) {
      writer.uint32(48).int64(message.param1);
    }
    if (message.param2 !== 0) {
      writer.uint32(56).int64(message.param2);
    }
    if (message.pc !== 0) {
      writer.uint32(64).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(72).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gas = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.param1 = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.param2 = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptCall {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      to: isSet(object.to) ? bytesFromBase64(object.to) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      param1: isSet(object.param1) ? globalThis.Number(object.param1) : 0,
      param2: isSet(object.param2) ? globalThis.Number(object.param2) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptCall): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.to.length !== 0) {
      obj.to = base64FromBytes(message.to);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.param1 !== 0) {
      obj.param1 = Math.round(message.param1);
    }
    if (message.param2 !== 0) {
      obj.param2 = Math.round(message.param2);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptCall>, I>>(base?: I): ReceiptCall {
    return ReceiptCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptCall>, I>>(object: I): ReceiptCall {
    const message = createBaseReceiptCall();
    message.id = object.id ?? new Uint8Array(0);
    message.to = object.to ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.gas = object.gas ?? 0;
    message.param1 = object.param1 ?? 0;
    message.param2 = object.param2 ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptReturn(): ReceiptReturn {
  return { id: new Uint8Array(0), val: 0, pc: 0, is: 0 };
}

export const ReceiptReturn: MessageFns<ReceiptReturn> = {
  encode(message: ReceiptReturn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.val !== 0) {
      writer.uint32(16).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(24).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(32).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptReturn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptReturn {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptReturn): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptReturn>, I>>(base?: I): ReceiptReturn {
    return ReceiptReturn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptReturn>, I>>(object: I): ReceiptReturn {
    const message = createBaseReceiptReturn();
    message.id = object.id ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptReturnData(): ReceiptReturnData {
  return { id: new Uint8Array(0), ptr: 0, len: 0, digest: new Uint8Array(0), data: new Uint8Array(0), pc: 0, is: 0 };
}

export const ReceiptReturnData: MessageFns<ReceiptReturnData> = {
  encode(message: ReceiptReturnData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.ptr !== 0) {
      writer.uint32(16).int64(message.ptr);
    }
    if (message.len !== 0) {
      writer.uint32(24).int64(message.len);
    }
    if (message.digest.length !== 0) {
      writer.uint32(34).bytes(message.digest);
    }
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    if (message.pc !== 0) {
      writer.uint32(48).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(56).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptReturnData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptReturnData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ptr = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.len = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptReturnData {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      ptr: isSet(object.ptr) ? globalThis.Number(object.ptr) : 0,
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptReturnData): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.ptr !== 0) {
      obj.ptr = Math.round(message.ptr);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptReturnData>, I>>(base?: I): ReceiptReturnData {
    return ReceiptReturnData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptReturnData>, I>>(object: I): ReceiptReturnData {
    const message = createBaseReceiptReturnData();
    message.id = object.id ?? new Uint8Array(0);
    message.ptr = object.ptr ?? 0;
    message.len = object.len ?? 0;
    message.digest = object.digest ?? new Uint8Array(0);
    message.data = object.data ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptPanic(): ReceiptPanic {
  return { id: new Uint8Array(0), reason: 0, pc: 0, is: 0, contractId: new Uint8Array(0) };
}

export const ReceiptPanic: MessageFns<ReceiptPanic> = {
  encode(message: ReceiptPanic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.reason !== 0) {
      writer.uint32(16).int64(message.reason);
    }
    if (message.pc !== 0) {
      writer.uint32(24).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(32).int64(message.is);
    }
    if (message.contractId.length !== 0) {
      writer.uint32(42).bytes(message.contractId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptPanic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptPanic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reason = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptPanic {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      reason: isSet(object.reason) ? globalThis.Number(object.reason) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
    };
  },

  toJSON(message: ReceiptPanic): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.reason !== 0) {
      obj.reason = Math.round(message.reason);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptPanic>, I>>(base?: I): ReceiptPanic {
    return ReceiptPanic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptPanic>, I>>(object: I): ReceiptPanic {
    const message = createBaseReceiptPanic();
    message.id = object.id ?? new Uint8Array(0);
    message.reason = object.reason ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    message.contractId = object.contractId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseReceiptRevert(): ReceiptRevert {
  return { id: new Uint8Array(0), ra: 0, pc: 0, is: 0 };
}

export const ReceiptRevert: MessageFns<ReceiptRevert> = {
  encode(message: ReceiptRevert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.ra !== 0) {
      writer.uint32(16).int64(message.ra);
    }
    if (message.pc !== 0) {
      writer.uint32(24).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(32).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptRevert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptRevert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ra = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptRevert {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      ra: isSet(object.ra) ? globalThis.Number(object.ra) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptRevert): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.ra !== 0) {
      obj.ra = Math.round(message.ra);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptRevert>, I>>(base?: I): ReceiptRevert {
    return ReceiptRevert.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptRevert>, I>>(object: I): ReceiptRevert {
    const message = createBaseReceiptRevert();
    message.id = object.id ?? new Uint8Array(0);
    message.ra = object.ra ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptLog(): ReceiptLog {
  return { id: new Uint8Array(0), ra: 0, rb: 0, rc: 0, rd: 0, pc: 0, is: 0 };
}

export const ReceiptLog: MessageFns<ReceiptLog> = {
  encode(message: ReceiptLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.ra !== 0) {
      writer.uint32(16).int64(message.ra);
    }
    if (message.rb !== 0) {
      writer.uint32(24).int64(message.rb);
    }
    if (message.rc !== 0) {
      writer.uint32(32).int64(message.rc);
    }
    if (message.rd !== 0) {
      writer.uint32(40).int64(message.rd);
    }
    if (message.pc !== 0) {
      writer.uint32(48).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(56).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ra = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rb = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rc = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rd = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptLog {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      ra: isSet(object.ra) ? globalThis.Number(object.ra) : 0,
      rb: isSet(object.rb) ? globalThis.Number(object.rb) : 0,
      rc: isSet(object.rc) ? globalThis.Number(object.rc) : 0,
      rd: isSet(object.rd) ? globalThis.Number(object.rd) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptLog): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.ra !== 0) {
      obj.ra = Math.round(message.ra);
    }
    if (message.rb !== 0) {
      obj.rb = Math.round(message.rb);
    }
    if (message.rc !== 0) {
      obj.rc = Math.round(message.rc);
    }
    if (message.rd !== 0) {
      obj.rd = Math.round(message.rd);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptLog>, I>>(base?: I): ReceiptLog {
    return ReceiptLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptLog>, I>>(object: I): ReceiptLog {
    const message = createBaseReceiptLog();
    message.id = object.id ?? new Uint8Array(0);
    message.ra = object.ra ?? 0;
    message.rb = object.rb ?? 0;
    message.rc = object.rc ?? 0;
    message.rd = object.rd ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptLogData(): ReceiptLogData {
  return {
    id: new Uint8Array(0),
    ra: 0,
    rb: 0,
    ptr: 0,
    len: 0,
    digest: new Uint8Array(0),
    data: new Uint8Array(0),
    pc: 0,
    is: 0,
  };
}

export const ReceiptLogData: MessageFns<ReceiptLogData> = {
  encode(message: ReceiptLogData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.ra !== 0) {
      writer.uint32(16).int64(message.ra);
    }
    if (message.rb !== 0) {
      writer.uint32(24).int64(message.rb);
    }
    if (message.ptr !== 0) {
      writer.uint32(32).int64(message.ptr);
    }
    if (message.len !== 0) {
      writer.uint32(40).int64(message.len);
    }
    if (message.digest.length !== 0) {
      writer.uint32(50).bytes(message.digest);
    }
    if (message.data.length !== 0) {
      writer.uint32(58).bytes(message.data);
    }
    if (message.pc !== 0) {
      writer.uint32(64).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(72).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptLogData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptLogData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ra = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rb = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ptr = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.len = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptLogData {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      ra: isSet(object.ra) ? globalThis.Number(object.ra) : 0,
      rb: isSet(object.rb) ? globalThis.Number(object.rb) : 0,
      ptr: isSet(object.ptr) ? globalThis.Number(object.ptr) : 0,
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptLogData): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.ra !== 0) {
      obj.ra = Math.round(message.ra);
    }
    if (message.rb !== 0) {
      obj.rb = Math.round(message.rb);
    }
    if (message.ptr !== 0) {
      obj.ptr = Math.round(message.ptr);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptLogData>, I>>(base?: I): ReceiptLogData {
    return ReceiptLogData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptLogData>, I>>(object: I): ReceiptLogData {
    const message = createBaseReceiptLogData();
    message.id = object.id ?? new Uint8Array(0);
    message.ra = object.ra ?? 0;
    message.rb = object.rb ?? 0;
    message.ptr = object.ptr ?? 0;
    message.len = object.len ?? 0;
    message.digest = object.digest ?? new Uint8Array(0);
    message.data = object.data ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptTransfer(): ReceiptTransfer {
  return { id: new Uint8Array(0), to: new Uint8Array(0), amount: 0, assetId: new Uint8Array(0), pc: 0, is: 0 };
}

export const ReceiptTransfer: MessageFns<ReceiptTransfer> = {
  encode(message: ReceiptTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.to.length !== 0) {
      writer.uint32(18).bytes(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(34).bytes(message.assetId);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptTransfer {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      to: isSet(object.to) ? bytesFromBase64(object.to) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptTransfer): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.to.length !== 0) {
      obj.to = base64FromBytes(message.to);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptTransfer>, I>>(base?: I): ReceiptTransfer {
    return ReceiptTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptTransfer>, I>>(object: I): ReceiptTransfer {
    const message = createBaseReceiptTransfer();
    message.id = object.id ?? new Uint8Array(0);
    message.to = object.to ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptTransferOut(): ReceiptTransferOut {
  return { id: new Uint8Array(0), toAddress: new Uint8Array(0), amount: 0, assetId: new Uint8Array(0), pc: 0, is: 0 };
}

export const ReceiptTransferOut: MessageFns<ReceiptTransferOut> = {
  encode(message: ReceiptTransferOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.toAddress.length !== 0) {
      writer.uint32(18).bytes(message.toAddress);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(34).bytes(message.assetId);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptTransferOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptTransferOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toAddress = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptTransferOut {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      toAddress: isSet(object.toAddress) ? bytesFromBase64(object.toAddress) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptTransferOut): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.toAddress.length !== 0) {
      obj.toAddress = base64FromBytes(message.toAddress);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptTransferOut>, I>>(base?: I): ReceiptTransferOut {
    return ReceiptTransferOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptTransferOut>, I>>(object: I): ReceiptTransferOut {
    const message = createBaseReceiptTransferOut();
    message.id = object.id ?? new Uint8Array(0);
    message.toAddress = object.toAddress ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptScriptResult(): ReceiptScriptResult {
  return { result: 0, gasUsed: 0 };
}

export const ReceiptScriptResult: MessageFns<ReceiptScriptResult> = {
  encode(message: ReceiptScriptResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.gasUsed !== 0) {
      writer.uint32(16).int64(message.gasUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptScriptResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptScriptResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gasUsed = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptScriptResult {
    return {
      result: isSet(object.result) ? scriptResultTypeFromJSON(object.result) : 0,
      gasUsed: isSet(object.gasUsed) ? globalThis.Number(object.gasUsed) : 0,
    };
  },

  toJSON(message: ReceiptScriptResult): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = scriptResultTypeToJSON(message.result);
    }
    if (message.gasUsed !== 0) {
      obj.gasUsed = Math.round(message.gasUsed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptScriptResult>, I>>(base?: I): ReceiptScriptResult {
    return ReceiptScriptResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptScriptResult>, I>>(object: I): ReceiptScriptResult {
    const message = createBaseReceiptScriptResult();
    message.result = object.result ?? 0;
    message.gasUsed = object.gasUsed ?? 0;
    return message;
  },
};

function createBaseReceiptMessageOut(): ReceiptMessageOut {
  return {
    sender: new Uint8Array(0),
    recipient: new Uint8Array(0),
    amount: 0,
    nonce: new Uint8Array(0),
    len: 0,
    digest: new Uint8Array(0),
    data: new Uint8Array(0),
  };
}

export const ReceiptMessageOut: MessageFns<ReceiptMessageOut> = {
  encode(message: ReceiptMessageOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.recipient.length !== 0) {
      writer.uint32(18).bytes(message.recipient);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(34).bytes(message.nonce);
    }
    if (message.len !== 0) {
      writer.uint32(40).int64(message.len);
    }
    if (message.digest.length !== 0) {
      writer.uint32(50).bytes(message.digest);
    }
    if (message.data.length !== 0) {
      writer.uint32(58).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptMessageOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptMessageOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipient = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.len = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptMessageOut {
    return {
      sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(0),
      recipient: isSet(object.recipient) ? bytesFromBase64(object.recipient) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ReceiptMessageOut): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.recipient.length !== 0) {
      obj.recipient = base64FromBytes(message.recipient);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptMessageOut>, I>>(base?: I): ReceiptMessageOut {
    return ReceiptMessageOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptMessageOut>, I>>(object: I): ReceiptMessageOut {
    const message = createBaseReceiptMessageOut();
    message.sender = object.sender ?? new Uint8Array(0);
    message.recipient = object.recipient ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.len = object.len ?? 0;
    message.digest = object.digest ?? new Uint8Array(0);
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseReceiptMint(): ReceiptMint {
  return { subId: new Uint8Array(0), id: new Uint8Array(0), assetId: new Uint8Array(0), val: 0, pc: 0, is: 0 };
}

export const ReceiptMint: MessageFns<ReceiptMint> = {
  encode(message: ReceiptMint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subId.length !== 0) {
      writer.uint32(10).bytes(message.subId);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(26).bytes(message.assetId);
    }
    if (message.val !== 0) {
      writer.uint32(32).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptMint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptMint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptMint {
    return {
      subId: isSet(object.subId) ? bytesFromBase64(object.subId) : new Uint8Array(0),
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptMint): unknown {
    const obj: any = {};
    if (message.subId.length !== 0) {
      obj.subId = base64FromBytes(message.subId);
    }
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptMint>, I>>(base?: I): ReceiptMint {
    return ReceiptMint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptMint>, I>>(object: I): ReceiptMint {
    const message = createBaseReceiptMint();
    message.subId = object.subId ?? new Uint8Array(0);
    message.id = object.id ?? new Uint8Array(0);
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function createBaseReceiptBurn(): ReceiptBurn {
  return { subId: new Uint8Array(0), id: new Uint8Array(0), assetId: new Uint8Array(0), val: 0, pc: 0, is: 0 };
}

export const ReceiptBurn: MessageFns<ReceiptBurn> = {
  encode(message: ReceiptBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subId.length !== 0) {
      writer.uint32(10).bytes(message.subId);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    if (message.assetId.length !== 0) {
      writer.uint32(26).bytes(message.assetId);
    }
    if (message.val !== 0) {
      writer.uint32(32).int64(message.val);
    }
    if (message.pc !== 0) {
      writer.uint32(40).int64(message.pc);
    }
    if (message.is !== 0) {
      writer.uint32(48).int64(message.is);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiptBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiptBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.val = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pc = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiptBurn {
    return {
      subId: isSet(object.subId) ? bytesFromBase64(object.subId) : new Uint8Array(0),
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      assetId: isSet(object.assetId) ? bytesFromBase64(object.assetId) : new Uint8Array(0),
      val: isSet(object.val) ? globalThis.Number(object.val) : 0,
      pc: isSet(object.pc) ? globalThis.Number(object.pc) : 0,
      is: isSet(object.is) ? globalThis.Number(object.is) : 0,
    };
  },

  toJSON(message: ReceiptBurn): unknown {
    const obj: any = {};
    if (message.subId.length !== 0) {
      obj.subId = base64FromBytes(message.subId);
    }
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.assetId.length !== 0) {
      obj.assetId = base64FromBytes(message.assetId);
    }
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    if (message.pc !== 0) {
      obj.pc = Math.round(message.pc);
    }
    if (message.is !== 0) {
      obj.is = Math.round(message.is);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiptBurn>, I>>(base?: I): ReceiptBurn {
    return ReceiptBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiptBurn>, I>>(object: I): ReceiptBurn {
    const message = createBaseReceiptBurn();
    message.subId = object.subId ?? new Uint8Array(0);
    message.id = object.id ?? new Uint8Array(0);
    message.assetId = object.assetId ?? new Uint8Array(0);
    message.val = object.val ?? 0;
    message.pc = object.pc ?? 0;
    message.is = object.is ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
